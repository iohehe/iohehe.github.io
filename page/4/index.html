<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Penlab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Penlab">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Penlab">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="iohex">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Penlab" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Penlab</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-NDSS-14-RIPS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/01/NDSS-14-RIPS/" class="article-date">
  <time class="dt-published" datetime="2020-11-01T07:24:12.000Z" itemprop="datePublished">2020-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/01/NDSS-14-RIPS/">Simulation of Built-in PHP Feature for Precise Static Code Analysis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>文章题目： Simulation of Built-in PHP Feature for Precise Static Code Analysis.</p>
<p>作者： Johannes Dahse &amp; Toorstem Holz</p>
<p>RIPS研究PHP静态分析几乎绕不开的工具， 一是选择的时间点好，2014年左右PHP还是比较火的。二是工具确实不多。 这篇文章发了14年的NDSS，还是有些东西值得借鉴的。</p>
<h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><p>首先， 作者在技术背景部分分析了一些PHP这种highly dynamic lanuage的痛点。</p>
<p><img src="/NDSS-14-RIPS/image-20201101153514155.png" alt="image-20201101153514155"></p>
<ul>
<li><p>1） 动态类型&#x2F;弱类型</p>
<p>脚本语言在变量声明时不用声明类型的确给静态分析带来不少麻烦，而动态类型指的是在运行时类型是可以变得(its variables are not bound to a specific data type).</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var1</span> = <span class="number">1</span>; <span class="variable">$var2</span> = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="variable">$var2</span> = <span class="variable">$var1</span> + <span class="variable">$var2</span>; <span class="comment">//1 </span></span><br></pre></td></tr></table></figure>


</li>
<li><ol start="2">
<li>variable Variables</li>
</ol>
<p>这个貌似是PHP独有的，叫$$特性？</p>
 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line"><span class="variable">$x</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$$name</span>; <span class="comment">//test</span></span><br><span class="line"><span class="variable">$y</span> = $&#123;<span class="title function_ invoke__">getVar</span>()&#125;; <span class="comment">//变量名可以是一个表达式ZZ</span></span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li><p>Dynamic Arrays</p>
<p>动态数组，PHP的数组是hash table实现的。可以存任何不同的数据类型，而且在初始化的时候key值可以省略在运行时指定。</p>
<p><img src="/NDSS-14-RIPS/image-20201101154933544.png" alt="image-20201101154933544"></p>
</li>
</ol>
</li>
</ul>
<p>注意这里新添加的自动索引了6, 神不神奇？会按照“4”开始算，把”4”改成”664”就是’e’的索引就是666。（还是说脚本语言的不规范性）</p>
<ul>
<li><ol start="4">
<li><p>Dynamic Constants</p>
<p>通过define()在于形式动态定一个常量， 通过constant()运行时访问。</p>
</li>
</ol>
</li>
<li><ol start="5">
<li>Dynamic Function</li>
</ol>
<p>function动态调用， 这个说的就太多了。</p>
<p><img src="/NDSS-14-RIPS/image-20201101155917397.png" alt="image-20201101155917397"></p>
</li>
</ul>
<p>第2行向我们讲述了， 不仅变量名可以是表达式， 方法名也可以是表达式； 第三行是一个回调函数，在动态的时候才知道执行啥。另外，还有<code>fun_get_arg()</code>和<code>func_get_args()</code>在运行时动态从call site拿参数; <code>create_function()</code>动态创建一个方法体org。</p>
<ul>
<li><ol start="6">
<li><p>Dynamic Code </p>
<p>动态执行代码， 通过<code>eval</code>, <code>assert</code>，小马常用到。这些代码在动态运行时才能知道， 给静态分析增加了难度。</p>
</li>
</ol>
</li>
<li><ol start="7">
<li><p>Dynamic includes </p>
<p>这个吐糟也比较多， 大型PHP项目尝尝被分割成若干文件和目录，他们的拼接为静态分析也增加了难度。类似<code>include</code>，使用这种操作，将文件中的代码返回到include处。尤其是现在又加了惰性加载机制。autoload()这种在静态分析目前只有猜了。</p>
</li>
</ol>
</li>
<li><ol start="8">
<li>Built-in Functinos</li>
</ol>
<p>   本文关注和要解决的主要challenge。不像Java, PHP的内建函数都是用C写的， 在ZEND执行时调用。大约有228个扩展5701个内建函数， 他们在静态分析PHP代码时无法被hook到，这就导致了分析的不精确。</p>
</li>
</ul>
<p><img src="/NDSS-14-RIPS/image-20201101162437988.png" alt="image-20201101162437988"></p>
<p>如图，第二个位置月份可以是字符型， 这里如果要能探测到XSS就要对list(), printf()进行精确建模。</p>
<ul>
<li><ol start="9">
<li><p>Superglobals</p>
<p> 我们的超全局变量， 需要精确的标明哪些可控。开发者经常忽略FILES和SERVER的安全性。</p>
</li>
</ol>
</li>
</ul>
<h2 id="方法设计"><a href="#方法设计" class="headerlink" title="方法设计"></a>方法设计</h2><h3 id="纵览"><a href="#纵览" class="headerlink" title="纵览"></a>纵览</h3><ol>
<li><p>还是文件为单位， 首相将散乱在文件中的代码解析成main AST(脚本语言通常没有main方法做入口)， 然后将user-defined function们收集起来， 将函数名， 参数等信息存入分析环境， 然后将其函数体构建成separate AST独立于main AST。</p>
</li>
<li><p>有了 AST， 下一步构建CFG(控制流图)， 分析AST如果发现<code>conditional jump</code> ,  就开辟一个新的基本块(<code>basic block</code>);并使用<code>basic edge</code>相连接。</p>
</li>
<li><p>有了CFG， 下一步构建PDG(数据依赖图)咯， 以基本块为单位，每当一个BB产生， 就分析一下他的<code>adta flow</code> 。</p>
</li>
<li><p>实现Intra(过程内)和Inter(过程间)分析，当遇到<code>call site</code> 就在环境中找到该方法名并进入其AST进行分析，从而实现<code>inter</code>能力。</p>
</li>
<li><p>实现污点分析。</p>
</li>
</ol>
<p>(说的挺复杂，开源版的RIPS的基础分析能力还是以分析tokens流并以各种数据结构辅助追踪为主)</p>
<h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><p>那么本paper novel在什么地方呢：</p>
<ul>
<li>在污点分析时添加了sanitization tags来表明数据被过滤</li>
<li>为952个内建方法建模，从而更精准的把控整个分析流的变化</li>
<li>在处理include file时，当作functions来处理，而不是直接加入到当前CFG，防止重复分析, 减少开销</li>
<li>根据基本块边来总结他们之间的sanitization影响</li>
<li>实现了后向污点分析，每一个基本块的分析结果，cache到一个变量里。</li>
<li>使用上下文敏感字符分析(context-sensitive stirng analysis)来精炼污点分析结果，基于当前环境。</li>
</ul>
<h2 id="CFGBuilder"><a href="#CFGBuilder" class="headerlink" title="CFGBuilder"></a>CFGBuilder</h2><p>要构建一个CFG, 先定义statements, 划分基本块。</p>
<p><img src="/NDSS-14-RIPS/image-20201102203138487.png" alt="image-20201102203138487"></p>
<p>这里作者定义了几种划分基本块的stmt， 配合算法：  </p>
<p><img src="/NDSS-14-RIPS/image-20201102203339071.png" alt="image-20201102203339071"></p>
<p> 中间的循环AST上的每一个点，如果遇到四种stmt的情况。 </p>
<ul>
<li><p>JSTMT, 遇到IF, Switch, Try, Ternary, LogicalOr（后两个没见过）， 就递归分析每个分支下的基本块。将入口条件加到基本块头。</p>
</li>
<li><p>LSTMT, 生成循环基本块</p>
</li>
<li><p>SSTMT, 停止，基本块下的stmts不可达</p>
</li>
<li><p>RSTMT, return,到达return或者是探测到程序退出，就不和下一个基本块建立连接。</p>
<p>这里增量在<code>simluate()</code>方法上，来看。</p>
</li>
</ul>
<h2 id="simulating-Basic-Blocks"><a href="#simulating-Basic-Blocks" class="headerlink" title="simulating Basic Blocks"></a>simulating Basic Blocks</h2><p>静态分析能干的事，就是编译器或者解释器能干的事。 RIPS为获取基本块内的data flow, 在控制流的基础上进行所谓的simulating，实现simulating:</p>
<ol>
<li>制定symbols:   值-val, 变量名-varibale, 常量-constant, 数组-ArrayDimFetch… 每一个symbol都会有几个状态(type, encoding, sanitization)，通过观察状态变化做到对类型，编码以及sanitize的敏感。</li>
</ol>
<p>2）Block Summary: 此过程就是将制定的符号集在块中使用进行后向追踪。生成一些块属性(block Summary):</p>
<pre><code>  * DataFlow - 记录变量/数组的assign
  * Constants - 记录常量的assign
  * GlobalDefines - 记录名称，加入global scope
  * ReturnValue - 记录块中的返回值(每个块一个返回， return和exit后的代码丢弃)
  * registerGlobals - 记录使用extract()或者import_request_varibales()注册变量
</code></pre>
<p>在每个块的后向data flow分析后记录以上内容， 生成block summary.</p>
<ol start="3">
<li><p>Data Flow Analysis</p>
</li>
<li><p>Simulating Includes and Dynamic Code： php 的includes是一个动态表达式，通过路径去找，找到加入，若无正则匹配。eval同理。</p>
</li>
<li><p>Simulating Built-in Functions:</p>
</li>
</ol>
<p>​     本文重点。 对621个内建函数进行数据流建模， configured name and effected parameters. 分类如下：</p>
<ul>
<li>Alphanumeric(284):  返回值只有字母数字组成的，effectively sanitize. 如: md5(), strlen()</li>
<li>Argument(122): 原样返回实参或部分的, 如： trim(), strrev()</li>
<li>escape(20): mysql_real_escap_string()这种， 遇到将symbol中的sanitization属性打上SQLI_SQ 和 SQLI_DO标签(如果没遇到就SQLI_NQ)</li>
<li>Substring(6): substr(), chunk_split()这种，返回实参字串的。 </li>
<li>Encode(18):  urlencode(), base64_encode() …</li>
<li>Decode(25): urldecode(), base64_decode()…</li>
<li>Callbacks(51): 回调函数，如果调用函数名事字符串，就调用分析。如果是变量，正则猜测。</li>
</ul>
<h2 id="Intra-produral-Analysis"><a href="#Intra-produral-Analysis" class="headerlink" title="Intra-produral Analysis"></a>Intra-produral Analysis</h2><p>实现intra</p>
<h2 id="Inter-procedural-Analysis"><a href="#Inter-procedural-Analysis" class="headerlink" title="Inter-procedural Analysis"></a>Inter-procedural Analysis</h2><p>实现inter</p>
<h2 id="Simluating-Block-Edges"><a href="#Simluating-Block-Edges" class="headerlink" title="Simluating Block Edges"></a>Simluating Block Edges</h2><p>块与块之间的simluating, 考虑validation的情况</p>
<ul>
<li>operators(6): isset(), empty()…</li>
<li>Type  checks(21): is_numeric()…</li>
<li>File checks(11): is_file()…</li>
<li>Whitelists(3): array_search()</li>
<li>Regex(8): 正则</li>
</ul>
<p>（原来validatation的情况可以放到块与块间，这样就和sanitization的情况分开来去了）。</p>
<h2 id="Taint-Analysis"><a href="#Taint-Analysis" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>污点分析探测漏洞的过程略。:&gt;</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之前看这篇觉得没啥东西， 仔细分析来东西还是挺多的， 毕竟顶会。</p>
<p>他几乎把所有语言特性层和面向过程层的东西讲到了， 缺少OO层的分析，也是后来不上人针对发文的。</p>
<p>(为什么看起来这么高大上的东西开源版本用起来和…一样)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/01/NDSS-14-RIPS/" data-id="cl1d6sq8z0009ilw55bve7gux" data-title="Simulation of Built-in PHP Feature for Precise Static Code Analysis" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper/" rel="tag">paper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RAID-2020_Relfected_Server_XSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/26/RAID-2020_Relfected_Server_XSS/" class="article-date">
  <time class="dt-published" datetime="2020-10-26T00:47:41.000Z" itemprop="datePublished">2020-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/26/RAID-2020_Relfected_Server_XSS/">What&#39;s in an Exploit? An Empirical Analysis of Reflected Server XSS Exploitation Techniques</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/iohehe/research/RAID-2020-xss-stats-paper/xss-stats-paper.pdf">原文链接</a></p>
<p>本文发表自RAID2020年，作者来自微软、东北大学和纽约大学。一项对反射型XSS的实证分析研究。</p>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030143613662.png" alt="image-20201030143613662"></p>
<p>本文从XSSED和OPENBUGBOUNTY两个网站收集了近十年来的反射型XSS提交的payload。 两个测试集OBB的比较新一些。</p>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030162110612.png" alt="image-20201030162110612"></p>
<p>在此即上进行EXP分析，设计了一个验证系统。证明这些反射型的EXP是可以被精确的识别出来的。</p>
<p>  <img src="/RAID-2020_Relfected_Server_XSS/image-20201030162154660.png" alt="image-20201030162154660"></p>
<p>整个系统分为动态和静态两个佐证部分，尝试识别出每个exp的trick:</p>
<ul>
<li><p>静态：</p>
<p>静态部分是:EXP Extraction ​到​ ​S​t​a​ti​c​ ​F​e​a​t​ur​e​ ​E​x​t​ra​c​t​i​on。​ 其实我觉得还带是正则。</p>
</li>
<li><p>动态：</p>
<p>动态部分是：EXP Execution 到 Dynamic Feature Extraction。 将收集的response的page使用chrome和FireFox加载，在沙箱环境中观察，因为有一些触发条件需要特定操作或者加载资源，因此作者分了四个round，后三个round需要操作(Mouse Move, Mouse Click, Network Error)，通过在response page中插桩，观察XSS执行里的trick。</p>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030173010493.png" alt="image-20201030173010493"></p>
</li>
</ul>
<p>下面来看看对payload的一些分统计：</p>
<ol>
<li><p>Context( Escaping and Creation)技术:</p>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030163940277.png" alt="image-20201030163940277"></p>
</li>
</ol>
<p>这一类主要是指逃逸+构造，日常使用中确实最多。细分为： HTML环境注释逃逸法、 JS环境注视逃逸法、属性环境标签闭合逃逸+构造标签、属性环境属性闭合+构造属性、JS环境代码续接。 （我瞎编的:expressionless:)​</p>
<ol start="2">
<li>Synatx Confusion技术</li>
</ol>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030164425916.png" alt="image-20201030164425916"></p>
<p>这一类就是语法混淆，包括： 方法名的额外括号、大小写混淆、 unicode编码混淆(乱入：注意方法括号不能unicode)、第四个厉害了没听说过、 空白符混淆、 斜杠替换空格(还有alert(&#x2F;xss&#x2F;))、 标签解析混淆(频率还很高，mark!)</p>
<ol start="3">
<li>Control Flow Modification技术</li>
</ol>
<p>此技术在OBB的测试集中使用比较多。也就是有48.2%的</p>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030165941047.png" alt="image-20201030165941047"></p>
<p>这个分类粒度是控制流更改(可能喝上两种不是一个维度)。主要是躲过&lt;script&gt;标签过，有1, 自动触发事件 2，exploit-triggered events(咋翻译？) 3,用户交互事件  4, 将事件赋给一个变量！ 5，抛异常！！</p>
<p>这个类型分的有点混乱，可能我还没看仔细。</p>
<ol start="4">
<li><p>字符解释技术</p>
<p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030171318469.png" alt="image-20201030171318469"></p>
<p>能够将字符当作JS代码解释的方法， 1，document.write 2, eval 3, setTimeout 4, top (写一遍加深印象…)</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/RAID-2020_Relfected_Server_XSS/image-20201030171651652.png" alt="image-20201030171651652"></p>
<p>En…还是闭合标签感觉爽些。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>看完这篇文章其他部分没仔细看， 光学姿势去了…</p>
<ul>
<li>可能有些位置就是可以用多种方法，最近趋于喜欢直接用svg做注入</li>
<li>是时候总结一波姿势了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/26/RAID-2020_Relfected_Server_XSS/" data-id="cl1d6sq93000filw50ms8cp6w" data-title="What&#39;s in an Exploit? An Empirical Analysis of Reflected Server XSS Exploitation Techniques" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper/" rel="tag">paper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-recuv" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/15/recuv/" class="article-date">
  <time class="dt-published" datetime="2020-09-15T03:13:08.000Z" itemprop="datePublished">2020-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/15/recuv/">递归</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>设计一个递归函数， 考虑三个方面： 参数、 中间量、返回值</p>
<ul>
<li><p>参数： 设计递归表达式中包含的关键东西， 每一次调用，只有参数在改变。</p>
</li>
<li><p>中间量：中间每次调用时，会在一个新的栈中存储，他在内存上和上次的变量是两块独立的空间，他们的行为只依赖于参数的变化。</p>
</li>
<li><p>返回值： 需要所有过程共同的return值来完成。</p>
</li>
</ul>
<p>每一次函数调用，都有一个独立的函数栈空间， 理解好这个就可以更好的理解递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new_str = [] // 返回值</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">_<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">global</span> new_str</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(_<span class="built_in">str</span>) &gt; <span class="number">1</span>): //中间量</span><br><span class="line">        x = _<span class="built_in">str</span>.pop() //中间量</span><br><span class="line">        new_str.append(x)</span><br><span class="line">        recv(_<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">return</span> new_str</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    _<span class="built_in">str</span> = [<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;0&quot;</span>] //参数</span><br><span class="line">    res = recv(_<span class="built_in">str</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>之前在遍历子路径时没想明白， 就在于我没有理解好每一次调用变量都存在独立的站。在递归返回上一级的时候，父函数在工作环境中继续施工，所以之前的内容都在。哈哈哈真的是，太菜了</p>
<p>(这里的new_str不写在递归区域， 因为new_str是返回值，所以不能每个过程都开一个新的，而是每次都将结果压入一个共同的空间中)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/15/recuv/" data-id="cl1d6sq9e001eilw50bej0crh" data-title="递归" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-taint" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/09/taint/" class="article-date">
  <time class="dt-published" datetime="2020-09-09T01:34:58.000Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/09/taint/">taint</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如下是一个典型污点分析算法：</p>
<p><img src="/taint/%E6%88%AA%E5%B1%8F2020-09-09%20%E4%B8%8A%E5%8D%889.38.59.png" alt="截屏2020-09-09 上午9.38.59"></p>
<p>一般地，污点分析会选择后向追踪。如果前向按照程序执行的方向追踪，即从sources找sinks往往会有很多误报。 从sinks后向找的话首先定位了漏洞点了。后向的话就是在一个赋值过程中<code>左值为污点传播给右值(lval-&gt;rval)</code> 那么一个后向算法的实现：</p>
<ul>
<li>第一步： 根据设定的sinks列表， 在程序中全局定位所有的sinkNodes的位置</li>
<li>第二步： 对每一个sinkNode进行后向追随，看有没有能够达到我们设定为sources的静态路径， 有就存为vulnerablePaths</li>
</ul>
<p>关键在于对每一个sink点如何追溯， 这里先不考虑地22行的filter。找到&lt;sink, source&gt;路径，核心是一个递归过程。这个过程的原操作是在数据流上向后走到下一个传播点，并将其标注为污点(taint)。 那么这个过程何时停？ 根据第18行，即当追到一个taint就是我们的sources，当然输出一条vulnerablePath。 当追到了Parameters时，此时此过程中的污点传播已经到头，说明污点已经传入了他的caller中，将此路径保存，停止污点追溯，回到他的caller中，如果caller中构造了vulnerablePaths，在讲这种由return传播到parameter的过程路径拼接。</p>
<p><img src="/taint/WechatIMG10.jpeg" alt="WechatIMG10"></p>
<p>上图描述了从sink开始找到一个赋值语句，转移函数在这里要回答右值是否标为污点？但是他的表达式中有一个call，要回答这个问题就我们就要分析这个调用。</p>
<p>如果将这个call看作一个黑盒的话，首先它一定要有返回值，如果没有返回值， 那么就没有数据传到sink点了(这里考虑的是显式传播，不考虑控制流的影响)。其次，要看我们的taint点，是否做为实参传入，如果做为实参传入，且从return点能够从数据流后向走到Parameters(这个taint的传入位置)，那么就做为一个子过程，拼接到path上(path+call_path)。 还有就是自过程中包含source，那么这个source直接就通过return和sink拼接成vulpath了。</p>
<p>递归过程:</p>
<ol>
<li>检查call中是否有返回</li>
<li>有返回值，标注污点传入的参数位置</li>
<li>将返回点做为sink，后向污点分析，如果遇到source,输出vul_path；走到标注的参数，返回路径；遇到call继续递归该过程。</li>
</ol>
<p> 给出一个Example，有空可以探测试一下。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo_1</span>(<span class="params"><span class="variable">$foo_1_param</span></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$foo_1_res</span> = <span class="string">&quot;&lt;a&gt;&quot;</span>.<span class="variable">$foo_1_param</span>.<span class="string">&quot;&lt;/a&gt;&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$foo_1_res</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo_2</span>(<span class="params"><span class="variable">$foo_2_param</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$foo_2_res</span> = <span class="title function_ invoke__">foo_1</span>(<span class="variable">$foo_2_param</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$foo_2_res</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$pass_2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_1</span> = <span class="title function_ invoke__">foo_2</span>(<span class="variable">$pass_2</span>);</span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$pass_1</span>;</span><br><span class="line">    <span class="title function_ invoke__">evil</span>(<span class="variable">$target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"><span class="variable">$target</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$target</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">bar</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>





<ul>
<li><code>evil($target)</code>: 污点标为target</li>
<li><code>$target = $pass_1</code>: 污点标为$pass_1</li>
<li><code>$pass_1 = foo_2($pass_2)</code>: 污点标为foo_2的第一个Argument，转入foo_2<ul>
<li>foo_2标记第一个Parameter</li>
<li>foo_2有return，从return开始追踪</li>
<li><code>return $foo_2_res</code>: 标记$foo_2_res为污点</li>
<li><code>$foo_2_res = foo_1($foo_2_param)</code>: 标记foo_2_param为污点，转入foo_1<ul>
<li>foo_1标记第一个Parameter</li>
<li>foo_1有return，从return开始追踪</li>
<li><code>return $foo_1_res</code>: 标记$foo_1_param为污点</li>
<li><code>$foo_1_res = &quot;&lt;a&gt;&quot;.$foo_1_param.&quot;&lt;/a&gt;&quot;;</code>：标记$foo_1_param为污点</li>
<li><code>function foo_1($foo_1_param)</code>: 污点传入标记的Parameter, 返回call_path</li>
</ul>
</li>
<li><code> $foo_2_res = foo_1($foo_2_param);</code>: 拼接call_path,标记$foo_2_res为污点</li>
<li><code>function foo_2($foo_2_param)</code>: 污点传入标记的Parameter, 返回call_path</li>
</ul>
</li>
<li><code>    $pass_1 = foo_2($pass_2)</code>: 标记$pass_1为污点</li>
<li><code> $pass_2 = $_GET[&#39;id&#39;];</code>: 找到source点，输出vulPath</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/09/taint/" data-id="cl1d6sq9m001yilw56wem15v8" data-title="taint" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-byte" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/19/byte/" class="article-date">
  <time class="dt-published" datetime="2020-08-19T07:38:19.000Z" itemprop="datePublished">2020-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/19/byte/">byte</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>计算机和计算器的区别是什么？抛开体积、功能等等，我觉得最本质的区别还是处理的信息域。 计算器只有数学语言的有限编码，它更像是封装了计算机的一个处理数学符号的软件而已。 </p>
<p>而为什么计算机可以处理几乎所有的信息域呢？计算机可以通过二进制的0和1，创造出更加丰富的编码来表示更多种类的信息。起初可能计算机和计算器没什么不同，只是在处理一些数学运算。但是人们想通过它来处理文字信息。 对于英文这种拼音文字，大小写52个，加上一些符号等等。首先我们要通过计算机表示这些符号，第一步就是要通过二进制去制定一个规则去表示(映射)他们。那么二进制中，1位可以携带两种信息，2位有2的二次方即4中组合来表示信息。那么8位是128个，装下日常看的英文信息应该够用了。为了保险，又扩展到8位刚好比较合适，能表示256种符号而且不会太大。ASCII码就是这么干的，当然可以其他的位数表示一个btye，但是现在通常来说，1btye&#x3D;8bits。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/19/byte/" data-id="cl1d6sq95000nilw5ff3v6ju9" data-title="byte" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rips" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/12/rips/" class="article-date">
  <time class="dt-published" datetime="2020-08-12T04:06:21.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/12/rips/">rips</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>抱着我一定要更新博客的决心， 我开始了RIPS折腾笔记。</p>
<h1 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h1><p>PHP静态分析有个里程碑式的工具-RIPS，这个工具是最早Dahse博士提出来的， 现在早已闭源。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%8812.11.26.png" alt="截屏2020-08-12 下午12.11.26"></p>
<p>到0.55是开源的最后一个版本。 </p>
<p>10年到17年期间，Dahse发表的文章有：</p>
<ul>
<li>2010 - RIPS-A static source code analyser for vulnerabilities in PHP scripts : 简单介绍RIPS工具，对应在0.3版本</li>
<li>2014 -  Simulation of Built-in PHP Features for Precise Static Code Analysis:  发表在NDSS上， 如何模拟内建函数来精确静态分析</li>
<li>2014 - Static Detection of Second-Order Vulnerabilities in Web Applications: 发表在USENIX上，二次注入漏洞探测问题。</li>
<li>2014 - Code Reuse Attacks in PHP: Automated POP Chain Generatio: 发表在CCS上，POP链探测</li>
<li>2015 - Experience report: an empirical study of PHP security mechanism usage: 一个软工的B</li>
<li>2016 - Thesis. Static Detection of Complex Vulnerabilities in Modern PHP Applications: 总结性的文章，毕业了…</li>
</ul>
<p>不得不说， 时间点卡的非常好， 10-15年正是PHP发展火爆的上升期，在14年发表了三篇也是醉了。如今四大上关注PHP的文章寥寥。</p>
<hr>
<h1 id="0x01-0-32版本工作流程"><a href="#0x01-0-32版本工作流程" class="headerlink" title="0x01 0.32版本工作流程"></a>0x01 0.32版本工作流程</h1><p>能找的最早版本，是RIPS-0.32，从这一版开始，结合文章资料开始分析，看RIPS是如何发展起来的。(此时还没有相对复杂的前端)</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%883.32.16.png" alt="截屏2020-08-12 下午3.32.16"></p>
<p>目录相对也简单， 直接index.php入口，也没有正则搜索功能了(虽然我平时只用这个)。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%883.38.13.png" alt="截屏2020-08-12 下午3.38.13"></p>
<p>画风可以说非常的清气，板正。</p>
<p><img src="/rips/6a04b428gy1g0zyyluaozg203j036no9.gif" alt="6a04b428gy1g0zyyluaozg203j036no9"></p>
<p>看代码入口处：</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%883.42.20.png" alt="截屏2020-08-12 下午3.42.20"></p>
<p>导入config里是一些需要使用的数据；functions里是处理token，扫描和输出三个功能；classes是定义了几个需要使用的数据结构(以类的形式，其实更像是结构体)。</p>
<p>根据作者的污点分析论述，此版本RIPS有139个PVFs(潜在漏洞函数)，首先第一步找到这些漏洞函数，这些PVFs标记在<code>config/PVF.php</code>中，如一个命令执行：</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%883.52.20.png" alt="截屏2020-08-12 下午3.52.20"></p>
<p>我们扫描这样一段代码：</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%883.28.27.png" alt="截屏2020-08-14 下午3.28.27"></p>
<p>看到没，这是一个命令执行，最后输出：</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%883.29.18.png" alt="截屏2020-08-14 下午3.29.18"></p>
<p>从效果上看，是一个完整有效的污点分析了噜， 大体来看这段代码的扫描是怎样实现的？ 大致分为三个阶段：读代码-&gt;token化-&gt;扫描。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8A%E5%8D%8810.47.59.png" alt="截屏2020-08-14 上午10.47.59"></p>
<p>   RIPS将所有文件读入到$data，然后循环针对每一个文件进行scan_file。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%884.14.08-7392902.png" alt="截屏2020-08-14 下午4.14.08"></p>
<blockquote>
<p>file_name文件名， scan_functions目标PVFs，其他T开头的都是从tokens中读取的标识好的token集合。</p>
</blockquote>
<p>进入<code>scan_file</code>方法也就是进入了<code>functions/scan.php</code>这个文件中，它是扫描的主逻辑所在地，文件在此完成扫描。先进行token化代码然后在此之上进行一些处理</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%884.25.13.png" alt="截屏2020-08-14 下午4.25.13"></p>
<p>这里的<code>$lines_pointer</code>是一个<code>scan_file</code>里注册的一个局部变量，用来装目标源码的。总之做了一些处理，放入到<code>$tokens</code>这个就是待分析源吗的目标token，进行<code>prepare_tokens</code>和<code>fix_tokens</code>，这里使用token进行污点分析的一个很关键的点就是我们分析每一个token的时候可以通过当前token的标号在<code>$tokens</code>这个数组中随意提取周围的token以确定代码环境。这样我们就需要把<code>$tokens</code>进行一些处理，比如去掉空格这种东西，因为<code>$a=$b</code>有的人会加任意空格<code>$a = $b</code>这样我们计算这个表达式的时候比如扫描到了<code>$a</code>我们需要知道这是不是一个<code>declare</code>就要在<code>$tokens[i+1]</code>找等号。这些工作是在token处理中完成的(<code>prepare_tokens</code>)，然后这里是在一个基本块里的例子，<code>fix_tokens</code>没什么用所以先不理会。</p>
<p>接下来就是扫描阶段：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$tokencount</span>=<span class="title function_ invoke__">count</span>(<span class="variable">$tokens</span>); <span class="variable">$i</span>&lt;<span class="variable">$tokencount</span>; <span class="variable">$i</span>++) <span class="comment">//遍历每一个token</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable">$token</span> = <span class="variable">$tokens</span>[<span class="variable">$i</span>]; <span class="comment">//此处既有当前token又保留了tokens可以随意提取周围token。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$token</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    ...token是数组处理</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    token不是数组处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处迭代每一个<code>$tokens</code>。分为数组和非数组两大块，每一块又分不同的情形：</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%884.51.44.png" alt="截屏2020-08-14 下午4.51.44"></p>
<p>这里简单记录了一下他的注释。针对每种情况的不同 RIPS有自己处理的case。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%885.09.07.png" alt="截屏2020-08-14 下午5.09.07"></p>
<p>看对上边的代码进行扫描，起作用的token，看到这个最简单的污点追踪，分别有<code>variable declarations</code>和标红的<code>check if token is a function call and a function to scan</code></p>
<h2 id="变量声明信息"><a href="#变量声明信息" class="headerlink" title="变量声明信息"></a>变量声明信息</h2><p>在扫描到第0个token的时候，进入这个判断:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="variable">$token_name</span> === T_VARIABLE</span><br><span class="line">					&amp;&amp; ( <span class="variable">$tokens</span>[<span class="variable">$i</span>+<span class="number">1</span>][<span class="number">0</span>] === <span class="string">&#x27;=&#x27;</span> || <span class="comment">// normal assignment</span></span><br><span class="line">					  (<span class="title function_ invoke__">in_array</span>(<span class="variable">$tokens</span>[<span class="variable">$i</span>+<span class="number">1</span>][<span class="number">0</span>], <span class="variable">$T_ASSIGNMENT</span>))  <span class="comment">// mathematical assignment</span></span><br><span class="line">					  || (<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>][<span class="number">0</span>] === T_AS <span class="comment">// foreach($var as $key=&gt;$value)</span></span><br><span class="line">					   || (<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>][<span class="number">0</span>] === T_DOUBLE_ARROW</span><br><span class="line">					    &amp;&amp; <span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">2</span>][<span class="number">0</span>] === T_VARIABLE)) </span><br><span class="line">					   || (<span class="variable">$tokens</span>[<span class="variable">$i</span>+<span class="number">1</span>] === <span class="string">&#x27;[&#x27;</span>  <span class="comment">// $foo[&#x27;a&#x27;], hard to check all keys and assignments</span></span><br><span class="line">					   <span class="comment">// example: $a[0][$i+$k] &amp;= $_GET[&#x27;a&#x27;];</span></span><br><span class="line">					   <span class="comment">// easier: the last token was an ending statement or beginning of the file</span></span><br><span class="line">					   &amp;&amp; (<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>] === <span class="string">&#x27;&#125;&#x27;</span> || <span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>] === <span class="string">&#x27;&#123;&#x27;</span> </span><br><span class="line">						|| <span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>] === <span class="string">&#x27;;&#x27;</span> || !<span class="keyword">isset</span>(<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>][<span class="number">0</span>]))) </span><br><span class="line">					  ) </span><br></pre></td></tr></table></figure>

<p>这个条件很长， 为了涵盖所有变量声明的形式，此处是最简单的<code>normal assignment</code>也就是在<code>$tokens[$i+1][0]</code>处发现了<code>=</code>，即0号token是一个变量而1号token是一个’&#x3D;’也就是说这个变量是一个左值，他正在被注册，因此进入该逻辑，new 一个<code>varDeclare</code>来注册这个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	</span><br><span class="line">// variable declarations = childs</span><br><span class="line">	class VarDeclare</span><br><span class="line">	&#123;</span><br><span class="line">		public $id;</span><br><span class="line">    	public $value;</span><br><span class="line">    	public $line;	</span><br><span class="line">		public $marker;</span><br><span class="line">		public $dependencies;</span><br><span class="line">		</span><br><span class="line">		function __construct($value = null) </span><br><span class="line">		&#123;</span><br><span class="line">			$this-&gt;id = 0;</span><br><span class="line">			$this-&gt;value = $value;</span><br><span class="line">			$this-&gt;line = &#x27;&#x27;;</span><br><span class="line">			$this-&gt;marker = 0;</span><br><span class="line">			$this-&gt;dependencies = array();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>首先进入这个逻辑：</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%885.27.13.png" alt="截屏2020-08-14 下午5.27.13"></p>
<p>先经过getmultiline的处理（提取整句语句），然后注册一个对象，填数据。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%885.29.19.png" alt="截屏2020-08-14 下午5.29.19"></p>
<p>然后把它插入到<code>$var_declares_global</code>中供之后分析使用(如果是函数内部的变量注册到<code>$var_declares_local</code>数组中)。同理，第7个token亦是如此。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%885.32.23.png" alt="截屏2020-08-14 下午5.32.23"></p>
<p>这样我们便能拿到所有的变量声明信息。</p>
<h2 id="PVF分析"><a href="#PVF分析" class="headerlink" title="PVF分析"></a>PVF分析</h2><p>当到走到第四行的<code>system</code>token后判断他是一个PVF。这是后就注册一个<code>VlnTreeNode</code>然后进行污点分析， 因为认为这个污点函数的参数是之前的变量传播的，与后边的token无关，因此触发一次污点分析。</p>
<p>找到PVF system的token后， rips就开始生成一个<code>VulnTreeNode</code>对象，叫做<code>$new_find</code>，来记录这个污点链。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%884.34.39.png" alt="截屏2020-08-12 下午4.34.39"></p>
<p>初始化了name，和lines(第4行的system)。接下来进行污点追踪，我们来看scan_parameter这个函数的标头：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scan_parameter</span>(<span class="params"><span class="variable">$file_name</span>, <span class="variable">$mainparent</span>, <span class="variable">$parent</span>, <span class="variable">$var_name</span>, <span class="variable">$var_declares</span>, <span class="variable">$last_token_id</span>, <span class="variable">$var_declares_global</span>, <span class="variable">$function_params</span>, <span class="variable">$function_obj</span>, <span class="variable">$userinput</span>, <span class="variable">$F_SECURES</span>, <span class="variable">$return_scan</span>=<span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>开始进入的时候<code>$mainparent</code>和<code>$parent</code> 都是由<code>$new_find</code>传来的:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$userinput</span> = <span class="title function_ invoke__">scan_parameter</span>(<span class="variable">$file_name</span>, <span class="variable">$new_find</span>, <span class="variable">$new_find</span>, <span class="variable">$trace_par_var</span>, <span class="variable">$var_declares_global</span>, <span class="variable">$i</span>+<span class="variable">$c</span>, <span class="literal">null</span>, <span class="keyword">array</span>(), <span class="literal">null</span>, <span class="literal">false</span>, <span class="variable">$scan_functions</span>[<span class="variable">$token_value</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%889.20.34.png" alt="截屏2020-08-14 下午9.20.34"></p>
<p>这么进来了，<code>$trace_par_var</code>是第一个参数也就是<code>$b</code>，追踪这一个变量，直到找到相关的declare，然后递归…</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%889.22.15.png" alt="截屏2020-08-14 下午9.22.15"></p>
<p>此时栈中有两个<code>scan_parameter</code>了， 第一个是<code>$b</code>，第二个是<code>$a</code>，此时<code>$mainparent</code>不变，而<code>$parent</code>更新， <code>$var_name</code>也是这一次递归的目标变量<code>$a</code>，继续…</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-14%20%E4%B8%8B%E5%8D%889.26.29.png" alt="截屏2020-08-14 下午9.26.29"></p>
<p>看一下三次递归：</p>
<ul>
<li><p>$last_token_id: 13-&gt;7-&gt;0</p>
</li>
<li><p>$var_name: $b-&gt;$a-&gt;$_GET[‘a’]</p>
</li>
</ul>
<p>其中还有一些变量的变化还没有仔细去追。总之走到userinput之后，<code>scan_parameter</code>出栈的时候会通过<code>output.php</code>进行记录，然后整个结果展示粗来。</p>
<p><img src="/rips/%E6%88%AA%E5%B1%8F2020-08-12%20%E4%B8%8B%E5%8D%884.41.00.png" alt="截屏2020-08-12 下午4.41.00"></p>
<p>okay~ 大致是这样。</p>
<h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><p>目前已经基本走通了一个基本块内的污点分析，做为一个完整的污点分析，你甭管在什么层面，用什么方法，只要能达到效果就成， 这里在token层面进行分析，判断条件写的也很复杂，主要就是想要通过对token环境的约束覆盖所有的情况来。那么接下来还要考虑控制语句(包括三元运算符)，过程间分析，OOP特性，语言动态特性…，总之，祝你幸福。</p>
<p>P.S. 本来想写完全分析的，有点长，有空再来篇新的。</p>
<p><img src="/rips/Unknown.jpeg" alt="Unknown"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/12/rips/" data-id="cl1d6sq9e001filw5axfr5j4h" data-title="rips" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-static-analysis-6-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/27/static-analysis-6-md/" class="article-date">
  <time class="dt-published" datetime="2020-07-27T01:10:33.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/27/static-analysis-6-md/">南大静态分析6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol start="7">
<li><p>Relate Iterative Algorithm to Fixed Point Theorem 4:20</p>
</li>
<li><p>May&#x2F;Must Analysis, A Lattice View  26:10</p>
</li>
<li><p>MOP and Distributivity 64:30</p>
</li>
<li><p>Constant Propagation 80:40</p>
</li>
<li><p>Worklist Algorithm 102:00</p>
<p>总结&amp;欢迎谭添老师</p>
</li>
</ol>
<h1 id="南大静态分析6"><a href="#南大静态分析6" class="headerlink" title="南大静态分析6"></a>南大静态分析6</h1><p>上回说到为了解决iterative algorithm中的三个问题， 我们引入了数学模型来进行形式化证明。 那么如何让在lattic上呈现的fixed point theorem与iterative algorithm关联起来呢？接下啦我们来看。</p>
<p>首先回顾一下iterative algorithm的三个问题：</p>
<h2 id="Review-The-Questions-We-Have-Seen-Before"><a href="#Review-The-Questions-We-Have-Seen-Before" class="headerlink" title="Review The Questions We Have Seen Before"></a>Review The Questions We Have Seen Before</h2><img src="static-analysis-6-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.34.28.png" alt="截屏2020-05-30 上午8.34.28 " style="zoom:60%;" />

<p>我们现在尝试回答三个问题。</p>
<img src="static-analysis-6-md/%E6%88%AA%E5%B1%8F2020-07-29%20%E4%B8%8A%E5%8D%888.56.22.png" alt="截屏2020-07-29 上午8.56.22 " style="zoom:20%;" />





<blockquote>
<ol>
<li>算法一定能达到不动点吗？(lattice 上单调性问题)</li>
<li>如果有不动点，只能有一个动点吗</li>
<li>不定点是解吗</li>
</ol>
</blockquote>
<h2 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed-Point Theorem"></a>Relate Iterative Algorithm to Fixed-Point Theorem</h2><blockquote>
<p> 04:20 </p>
</blockquote>
<p>将<code>Iterative Algorithm</code>这个算法与<code>fixed point </code>进行关联(一种很intuition的证明)：</p>
<ul>
<li>Iterative Algorithm</li>
</ul>
<img src="static-analysis-6-md/image-20210724073400818.png" alt="image-20210724073400818" style="zoom:8å0%;" />



<ul>
<li>Fixed point:</li>
</ul>
<p><img src="/static-analysis-6-md/image-20210724073420227.png" alt="image-20210724073420227"></p>
<p>将二者的已知条件进行关联， 首先iterative algorithm 也需定义一个Lattice:</p>
<img src="static-analysis-6-md/image-20210724092616707.png" alt="image-20210724092616707" style="zoom:60%;" />

<p>在算法的k-tuple中， 每一个节点对应一个Lattice, 那么所有节点形成的vector就是一个Lattice的product。 那么整个iterative algorithm作用的是一个product lattice。</p>
<ul>
<li><p>在product lattice (L, L, L…L)中， 如果每一个L都是finite的complete lattice（complete lattice不一定finite哦），那么他们构成的product lattice也是finite的complete lattice。</p>
<p>通过此条我们就可以关联上不动点定理的第二个条件： <code>L is finite</code></p>
</li>
</ul>
<p>现在我们来关联不动点定理的第一条件：<code>f: L-&gt;L is monotonic</code>, 如何说明，iterative  algorithm也是单调的呢？</p>
<p>首先，iterative algorithm的function是什么呢？</p>
<img src="static-analysis-6-md/image-20210724093452801.png" alt="image-20210724093452801" style="zoom:70%;" />

<p>如上所言，在每一次迭代中，都会应用一个<code>function F</code>, 他由两部分构成：</p>
<ul>
<li><p>transfer function: 指定的transfer function, 根据IN[B],来进行kill和gen</p>
</li>
<li><p>join&#x2F;meet function: 在控制流上，进入下一个program point之前的并&#x2F;交操作</p>
<blockquote>
<p> e.g., F(iter1) &#x3D; (v1….vk)</p>
</blockquote>
</li>
</ul>
<p>有了F, 接下来证明他是monotonic的：</p>
<img src="static-analysis-6-md/image-20210724094200039.png" alt="image-20210724094200039" style="zoom:50%;" />

<p>首先第一条之前也说过，每一个transfer function在固定的program point上，由程序性质所决定kill和gen都是一样的， 所以他是单调的(OUT只会增加，不会减少)。</p>
<p>再来证明第二条：</p>
<img src="static-analysis-6-md/image-20210724094430990.png" alt="image-20210724094430990" style="zoom:50%;" />

<p>这里的LXL是两条控制流path在进入program point之前进行merg, 也可以有多个(Actually the binary operator is a basic case), 我们只需要证明这个<code>basic case</code>是单调的就可以了。</p>
<p>我们来证join是单调的：</p>
<p>根绝我们之前对单调函数的定义:</p>
<img src="static-analysis-5-md/image-20210723224024442.png" alt="image-20210723224024442" style="zoom:50%;" />

<p>此时的function是一个join(U)操作， 因此，我们的function是证明:<img src="static-analysis-6-md/image-20210724095135553.png" alt="image-20210724095135553" style="zoom:50%;" />。</p>
<p>join在lattice求的是任意两个元素的最小上界(least upper bond)，那么<code>yUz</code>是y的upper bound，同时也是z的upper bond。根据upper bound 的定义得到:<img src="static-analysis-6-md/image-20210724095550037.png" alt="image-20210724095550037" style="zoom:50%;" />, 根据偏序关系中的传递性，我们就可以得出: <img src="static-analysis-6-md/image-20210724095708642.png" alt="image-20210724095708642" style="zoom:50%;" />, 然后得到完整的证明:</p>
<img src="static-analysis-6-md/image-20210724095809112.png" alt="image-20210724095809112" style="zoom:67%;" />

<p>因为根据join(U)的定义, yUz是y和z的一个upper bound，那么y &lt;&#x3D; yUz。 之后通过偏序关系(&lt;&#x3D;)的传递性得到: x&lt;&#x3D;yUz。因此，yUz就是x,y,z的一个upper bound。</p>
<p>根据join的定义xUz是least upper bound of x and z。 那么根据最小上界(least upper bound)的定义： xUz &lt;&#x3D; yUz。(最小上界“小于等于”任何一个上界)。</p>
<p>因此，现在将fixed point theorem的两个条件都和iterative algorithm有所关联了，那么就可以使用fixed point theorem 来说明之前提到的iterative algorithm for data flow analysis 上的问题。</p>
<p>给出两个结论，我们的iterative algorithm根据不动点定理：</p>
 <img src="static-analysis-6-md/image-20210724100647990.png" alt="image-20210724100647990" style="zoom:70%;" />



<ol>
<li>算法保证一定能够达到fixed point</li>
<li>达到的fixed point 要么是greatest fixed point, 要么是least fixed point</li>
<li>探讨algorithm的一个复杂度的问题，如果前边两条成立，那么什么时候算法才能达到不动点呢？</li>
</ol>
<p>为了说明第三点，首先引入<code>height of a lattice</code>的定义：</p>
<blockquote>
<p>The <code>height of a lattice h</code> is the length of the longest path from Top to Bottom in the lattice.</p>
</blockquote>
<img src="static-analysis-6-md/image-20210724101157035.png" alt="image-20210724101157035" style="zoom:50%;" />

<p>Lattice的高度就是从top到bottom找最长的路径，上图中是h&#x3D;3。</p>
<img src="static-analysis-6-md/image-20210724103312667.png" alt="image-20210724103312667" style="zoom:70%;" />

<p>第三个问题，就是说 The maximum iterations i, 最多的迭代次数，使得算法达到不动点(最坏的情况)。</p>
<p>做一个假设， 每次iteration, 在lattice上的每一步都做一个最微小的变化： lattice只移动移一步(相当于每次只有一个node变化， 且每个node中只有一个0变成1)。</p>
<img src="static-analysis-6-md/image-20210724103609474.png" alt="image-20210724103609474" style="zoom:80%;" /> 

<p>每次都只变化一个节点，将一个0变为1，那么最坏的情况就是遍历所有节点，将所有位由0变成1：</p>
<img src="static-analysis-6-md/image-20210724104202980.png" alt="image-20210724104202980" style="zoom:80%;" />

<p>最多就有h*k次iterations。</p>
<p>因此回答第三个问题：</p>
<img src="static-analysis-6-md/image-20210724104308251.png" alt="image-20210724104308251" style="zoom:67%;" />













<h2 id="May-and-Must-Analysis-a-Lattice-View"><a href="#May-and-Must-Analysis-a-Lattice-View" class="headerlink" title="May and Must Analysis, a Lattice View"></a>May and Must Analysis, a Lattice View</h2><blockquote>
<p>26:10</p>
</blockquote>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>将一个power set做一个直观的映射</p>
<img src="static-analysis-6-md/image-20210724110530341.png" alt="image-20210724110530341" style="zoom:30%;" />

<p>这里假设this lattice is a reuslt of the product lattice, 因为每一点都有一组k-tuple, 每一个点他都是一个lattice元素，我们要更新的是所有值，所以他是一个product lattice。</p>
<h3 id="May"><a href="#May" class="headerlink" title="May"></a>May</h3><img src="static-analysis-6-md/%E6%88%AA%E5%B1%8F2020-08-13%20%E4%B8%8A%E5%8D%888.50.36.png" alt="截屏2020-08-13 上午8.50.36 " style="zoom:50%;" />

<p>May analysis, 一般情况下是从bottom往top走， 一个lattice的bottom从may的角度来讲，就是一个<code>unsafe result</code>。 也就是说，</p>
<blockquote>
<p>无论是 may analysis 还是 must analysis都是从unsafe的result向safe的result来讲的。</p>
</blockquote>
<ul>
<li><p>Unsafe result : 为什么May analysis的unsafe 是在bottom呢？ 以 reaching definition为例， no definitions can reach 意味着对于每一个variable, 都没有任何一个defintion能够reach到。</p>
</li>
<li><p>Safe but useless result: 以reaching definition为例，表示对于每一个variable, 所有的definitions都有可能reach。他是safe的，但是没有用。</p>
</li>
</ul>
<p>我们想知道，我们的分析停在unsafe result 和safe but useless result 中间的某个值， 我们需要引入另外一个值： Truth。</p>
<img src="static-analysis-6-md/image-20210724114149446.png" alt="image-20210724114149446" style="zoom:30%;" />

<p>Truth, 程序动态执行时无论在什么样的书如下所有可能取得值的一个动态值的集合。</p>
<p>假设Lattice 上{a,c}是一个Truth的集合。 那么就可以画一条边界，如果是May的分析，就把a和c都包含。</p>
<img src="static-analysis-6-md/image-20210724114733084.png" alt="image-20210724114733084" style="zoom:33%;" />



<p>如何知道我们的分析会进入safe呢？</p>
<img src="static-analysis-6-md/image-20210724114839906.png" alt="image-20210724114839906" style="zoom:33%;" />

<p>静态分析有两个要素： </p>
<ol>
<li>data abstraction</li>
<li>safe approximation</li>
</ol>
<p>我们在设计一个静态分析时，将merg与transfer functie 设置成safe的，也就是说，我们的设计保证了我们的分析结果一定会超过Truth这一点。</p>
<p>进入safe之后何时停呢？</p>
<img src="static-analysis-6-md/image-20210724115204556.png" alt="image-20210724115204556" style="zoom:33%;" />

<p>我们的不动点可以有很多，但是虽然有很多不动点， 但是我们使用iterative alogrithm求解出的不动点，由我们之前给出的证明，iterative alogrithm求解出的不动点，一定是最小不动点(least fixed point)。</p>
<p>那么我们得到的结果精度如何呢?</p>
<img src="static-analysis-6-md/image-20210724115547408.png" alt="image-20210724115547408" style="zoom:30%;" />

<p>无论是may还是must分析， 都是从准到不准走。 如上图，越往上的不动点越不准的，因为我们使用iterative algorithm能达到的是leaset fixed point, 那就是你能达到的所有结果中，最准的。这就是为什么一旦达到不动点，但是我们达到的fixed points里最准的(但他不一定是truth)。</p>
<h3 id="MUST"><a href="#MUST" class="headerlink" title="MUST"></a>MUST</h3><img src="static-analysis-6-md/%E6%88%AA%E5%B1%8F2020-08-13%20%E4%B8%8A%E5%8D%888.54.34.png" alt="截屏2020-08-13 上午8.54.34 " style="zoom:50%;" />



<p>Must和May相反，一般是从Top(unsafe result)往下走到Bottom(Safe but unless result)。</p>
<p>以available expressions为例，他是一个must analysis:</p>
<ul>
<li>Top(unsafe result): 所有的expressions在某一点都available，结果unsafe。</li>
<li>Bottom(safe but unless result): No expressions are available, 么有expressions可以被重复利用， 所以是safe的，但是 没有用。</li>
</ul>
<p>在must analysis中， unsafe就是有误报的情况。 Must Analysis是top-down, 他根据iterative algorithm 走到的fixed point一定是greatest fixed point(就是最准的)。也就是说针对must analysis而言我们往下走到的greatest fixed point一定是最准的。</p>
<blockquote>
<p>Safe approximate 中safe是先满足的条件，能达到fixed point是后满足的。</p>
</blockquote>
<p>合照：</p>
<img src="static-analysis-6-md/image-20210724122023792.png" alt="image-20210724122023792" style="zoom:70%;" />















<h2 id="How-Precise-Is-Our-Solution"><a href="#How-Precise-Is-Our-Solution" class="headerlink" title="How Precise Is Our Solution?"></a>How Precise Is Our Solution?</h2><blockquote>
<p>64:30</p>
</blockquote>
<p>谈到精度的衡量， 我们就需要一个方法：</p>
<p>MOP: Meet-Over-All-Paths Solution(MOP)</p>
<p>其中，meet也包括了join, 就是所有分支汇聚到一点的情况。 具体就是：</p>
<img src="static-analysis-6-md/image-20210724151555790.png" alt="image-20210724151555790" style="zoom:30%;" />

<p>在control flow graph 中 path就是从entry开始一堆statement构成的Path； 有Path就有Transfer function <code>Fp</code>:</p>
<img src="static-analysis-6-md/image-20210724151716351.png" alt="image-20210724151716351" style="zoom:50%;" />

<p>就是这条流上每一点的transfer function 的composition。</p>
<img src="static-analysis-6-md/image-20210724151920020.png" alt="image-20210724151920020" style="zoom:20%;" />

<p>MOP(Meet-Over-All-Paths Solution)就是枚举从Entry点到Si的所有path, 然后对每条Path应用<code>Fp</code>， 并将得到的结果join&#x2F;meet起来：</p>
<img src="static-analysis-6-md/image-20210724152233463.png" alt="image-20210724152233463" style="zoom:33%;" />

<ul>
<li>not fully precise: 观察一下，所有的paths, may be not executable（动态运行时，无论什么输入之下都不能走的路径），在MOP中merge了此类路径，就是误报，所以就not fully precise。</li>
</ul>
<img src="static-analysis-6-md/image-20210724152410470.png" alt="image-20210724152410470" style="zoom:40%;" />

<ul>
<li><p>Unbounded, and not enumerable: unbound就是说如果有循环的话，静态不可知循环终止(无边界)； not enumerable: 大型程序中，路径可能不可枚举的。</p>
 <img src="static-analysis-6-md/image-20210724152837254.png" alt="image-20210724152837254" style="zoom:40%;" /></li>
</ul>
<p>所以我们静态得到MOP其实是impractical的。</p>
<h3 id="Iterative-Algorithm-vs-MOP"><a href="#Iterative-Algorithm-vs-MOP" class="headerlink" title="Iterative Algorithm vs. MOP"></a>Iterative Algorithm vs. MOP</h3><img src="static-analysis-6-md/image-20210724153327700.png" alt="image-20210724153327700" style="zoom:50%;" />

<p>如图， 我们要求S4点的IN:</p>
<p>使用<code>iteractive algorithm</code>, 在所有merge的时候，用join: <img src="static-analysis-6-md/image-20210724153422673.png" alt="image-20210724153422673" style="zoom:20%;" /></p>
<p>而使用<code>MOP(meet-over-all-paths)</code>的方法，是在每条path都算法之后，对每条path进行join:  <img src="static-analysis-6-md/image-20210724153642260.png" alt="image-20210724153642260" style="zoom:20%;" /></p>
<img src="static-analysis-6-md/image-20210724153730294.png" alt="image-20210724153730294" style="zoom:30%;" />

<p>上图我们可以看到，红色部分和黄色部分iterative algorithm 和 MOP其实是一样的，我们进行抽象：</p>
<img src="static-analysis-6-md/image-20210724153845650.png" alt="image-20210724153845650" style="zoom:33%;" />

<p>iterative algorithm和MOP有什么关系呢?</p>
<p> 证明:</p>
<img src="static-analysis-6-md/image-20210724154810672.png" alt="image-20210724154810672" style="zoom:30%;" />

<ul>
<li>根据最小上界(least upper bound)定义, 我们有： x join y即是x的上界又是y的上界 (x&lt;&#x3D;x u y and y &lt;&#x3D; x u y)。</li>
<li>因为一个transfer function是单调的，我们有：</li>
<li><img src="static-analysis-6-md/image-20210724155201184.png" alt="image-20210724155201184" style="zoom:33%;" /></li>
</ul>
<p>根据偏序关系， 这就意味着F(x u y) 是F(x)和F(y)的upper bound。</p>
<ul>
<li><p>因为F(x)uF(y)是F(x)和F(y)的least upper bound, 所以我们有:</p>
<img src="static-analysis-6-md/image-20210724155421510.png" alt="image-20210724155421510" style="zoom:33%;" />
</li>
<li><p>左边就是MOP右边就是Ours &#x3D;&gt; MOP &lt;&#x3D; Ours</p>
</li>
</ul>
<img src="static-analysis-6-md/image-20210724155530412.png" alt="image-20210724155530412" style="zoom:33%;" />

<p>因此， MOP更准。</p>
<p>上边证明出的MOP和Iteractive Algorithm(Ours)满足一个偏序关系， 那么偏序关系有一个自反性， 如果满足自反性，那么Iteractive Algorithm就可以和MOP的精度相同。</p>
<img src="static-analysis-6-md/image-20210724155905712.png" alt="image-20210724155905712" style="zoom:25%;" />

<p>当Function是一个distributive(可分配性)的，就可以和MOP一样准：</p>
<img src="static-analysis-6-md/image-20210724160020053.png" alt="image-20210724160020053" style="zoom:30%;" />

<p>之前的4个分析，都是distributive的； 这样一类操作都可以叫做Bit-vector problems(or Gen&#x2F;Kill problems)</p>
<blockquote>
<p>这里一类问题的集合操作都可以用集合的union和intersection操作</p>
</blockquote>
<p>Bit-vector problems都是distributive的。</p>
<p>那么有没有不是distributive的呢?(MOP更准)， 这里介绍了: <code>Constant Propagation</code>常量传播问题。</p>
<h2 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h2><p>Define: </p>
<p>Given a variable x at program point p, determine whether x is <code>guaranteed</code> to hold a constant value at p.</p>
<p>一个variable在某一点，是否保证x一定指向某一个常量。</p>
<ul>
<li>The OUT of each node in CFG, includes a set of pairs(x, v) where x is a variable and v is the value held by x after that node.</li>
</ul>
<p> 这里的data flow的每个点上是一个个的pairs, 他代表了variable与value的对应。</p>
<p>设计一个Constant Propagation的data flow analysis framework我们接下来考虑他的方向，格和transfer function:</p>
<img src="static-analysis-6-md/image-20210724161506207.png" alt="image-20210724161506207" style="zoom:33%;" />

<ul>
<li><p>Data flow direction: 数据流的分析方向是前向的。</p>
</li>
<li><p>Lattice:</p>
<img src="static-analysis-6-md/image-20210724165738837.png" alt="image-20210724165738837" style="zoom:33%;" /></li>
</ul>
<p>Lattice 来考虑两个构成部分:  Domain of the values; Meet Operator。</p>
<p>首先看Domain:</p>
<ul>
<li>Bottom: NAC- 所有的variables都不是constants(safe but useless)</li>
<li>Top: UNDEF-因为我们的元素是一个个的pair, 初始时variable指向undefine</li>
</ul>
<p>再来看Meet:</p>
<ul>
<li><p>NAC n V &#x3D; NAC， 不管V是啥，因为时safe的，汇聚点一定是NAC</p>
</li>
<li><p>UNDEF n V &#x3D; V， 这里说明一下，一般一个data flow analysis只负责一件事情，这里虽然有uninitialized variables的问题（汇聚后undef的值变成v了）。但是在以constant propagation为目的分析中，不影响。</p>
</li>
<li><p>c n v 分两种情况，如果常量相同就是c, 不同就是NAC</p>
</li>
</ul>
<p>总结：</p>
<img src="static-analysis-6-md/image-20210724171008706.png" alt="image-20210724171008706" style="zoom:33%;" />



<p>再来看Transfer Function:</p>
<img src="static-analysis-6-md/image-20210724171459396.png" alt="image-20210724171459396" style="zoom:33%;" />



<p>Transfer Function中，比较特殊的是{(x, _)}, 因为元素是一个pair, 所以这里_是一个通配符，表示x无论指向什么，都会减去。</p>
<p>我们用val(x), 来知道val指向的值：</p>
<ul>
<li>s: x &#x3D; c; gen{(x, c)}, x就指向c</li>
<li>s: x&#x3D; y;(非constant), val(y)</li>
<li>s: x &#x3D; y op z, 二元操作： 如果y, z 有一个是NAC，就是NAC， 有一个是UNDEF, 就是UNDEF, 如果两个都是常量val(y) op val(z)</li>
</ul>
<p>注意transform function只影响assignment statement。</p>
<p>下边说明contant propagation 不是distributivity:</p>
<img src="static-analysis-6-md/image-20210724172107062.png" alt="image-20210724172107062" style="zoom:33%;" />

<p>可以看到，F（XnY）时C是NAC， F(X)nF(Y)时C是10。</p>
<blockquote>
<p>从Lattice上看，此例中NAC在10下边，所以在这个must analysis中越往下越不准的，所以MOP更准一些。</p>
</blockquote>
<h2 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h2><p>worklist algorithm是iterative algorithm的一种优化。</p>
<blockquote>
<p>在实际工作中，不会用iterative algorithm, 而worklist algorithm更实用一些。</p>
</blockquote>
<img src="static-analysis-6-md/image-20210724172347184.png" alt="image-20210724172347184 " style="zoom:33%;" />

<p>这里的终止条件要求，只要有一个basic block变化，就要让所有的basic block 都跑一遍，会有很多冗余。 而worklist的核心，就是只对那些可能变化的BB执行transfer function：</p>
<img src="static-analysis-6-md/image-20210724172559644.png" alt="image-20210724172559644" style="zoom:33%;" />

<p>黄色的是新增的， 我们每一次迭代用新的out和之前的out比较， 如果一个out变了，那么意味着所有后继(successors)的IN变了。 我们就讲所有后继的B加入Worklist，就可以避免了大量的冗余计算。✌️～</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/27/static-analysis-6-md/" data-id="cl1d6sq9l001tilw5fmb2dn0j" data-title="南大静态分析6" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PHP-AST" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/01/PHP-AST/" class="article-date">
  <time class="dt-published" datetime="2020-05-31T16:00:00.000Z" itemprop="datePublished">2020-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>放在这，没事儿了我就总结几个</p>
<h1 id="1-child-nodes"><a href="#1-child-nodes" class="headerlink" title="1 child nodes"></a>1 child nodes</h1><h2 id="AST-VAR"><a href="#AST-VAR" class="headerlink" title="AST_VAR"></a>AST_VAR</h2><p><img src="/PHP-AST/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%884.07.05.png" alt="截屏2020-07-14 下午4.07.05"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span></span><br></pre></td></tr></table></figure>



<h2 id="AST-ECHO"><a href="#AST-ECHO" class="headerlink" title="AST_ECHO"></a>AST_ECHO</h2><p><img src="/PHP-AST/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%883.42.44.png" alt="截屏2020-07-27 下午3.42.44"></p>
<h1 id="2-child-nodes"><a href="#2-child-nodes" class="headerlink" title="2 child nodes"></a>2 child nodes</h1><h2 id="AST-CALL"><a href="#AST-CALL" class="headerlink" title="AST_CALL"></a>AST_CALL</h2><blockquote>
<p>函数调用点</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123106.png" alt="截屏2020-06-01 下午5.41.28"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">foo</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>child0:  ARG_LIST - 参数列表 </li>
<li>child1:  调用函数名</li>
</ul>
<h2 id="AST-DIM"><a href="#AST-DIM" class="headerlink" title="AST_DIM"></a>AST_DIM</h2><blockquote>
<p>数组引用</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123109.png" alt="截屏2020-06-01 下午5.48.46"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = foo[<span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure>



<ul>
<li>child0:  数组名</li>
<li>child1:  索引值</li>
</ul>
<h2 id="ZEND-AST-PROP"><a href="#ZEND-AST-PROP" class="headerlink" title="ZEND_AST_PROP"></a>ZEND_AST_PROP</h2><blockquote>
<p>属性调用</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123113.png" alt="截屏2020-06-20 下午4.39.26"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$obj</span>-&gt;val;</span><br></pre></td></tr></table></figure>



<ul>
<li>child0: objetct_name</li>
<li>child1: attr</li>
</ul>
<h2 id="ZEND-AST-WHILE"><a href="#ZEND-AST-WHILE" class="headerlink" title="ZEND_AST_WHILE"></a>ZEND_AST_WHILE</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123116.png" alt="截屏2020-06-20 下午4.42.05"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="variable">$a</span>==<span class="number">1</span>)&#123;</span><br><span class="line">  [stmt_list]...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>child0: condtion</li>
<li>child1: stmt_list</li>
</ul>
<h2 id="AST-IF-ELEMET"><a href="#AST-IF-ELEMET" class="headerlink" title="AST_IF_ELEMET"></a>AST_IF_ELEMET</h2><blockquote>
<p>区别于AST_IF</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-083801.png" alt="截屏2020-07-14 下午4.37.36"></p>
<p>AST_IF这个list下连接的每一个分支都由一个IF_ELEMENT进入。</p>
<ul>
<li>Child0 :条件判定式</li>
<li>Child1: 代码语句块</li>
</ul>
<h2 id="AST-BINARY-OP"><a href="#AST-BINARY-OP" class="headerlink" title="AST_BINARY_OP"></a>AST_BINARY_OP</h2><blockquote>
<p>二元操作</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-085207.png" alt="截屏2020-07-14 下午4.51.41"></p>
<p>控制流、数据流走判定表达式的话都是直接连这个点。代表整个二元操作表达式。 </p>
<p>在PHP-AST这个项目中， 此点有flags字段，决定作用方法：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nikic/php-ast/blob/1b5d767dd326f535288786130b2215744feb2cbf/tests/metadata.phpt#L97">https://github.com/nikic/php-ast/blob/1b5d767dd326f535288786130b2215744feb2cbf/tests/metadata.phpt#L97</a></p>
<ul>
<li><p>位逻辑运算 BINARY_BITWISE_OR, BINARY_BITWISE_AND, BINARY_BITWISE_XOR, </p>
</li>
<li><p>布尔逻辑运算 BINARY_BOOL_AND, BINARY_BOOL_OR, BINARY_BOOL_XOR,</p>
</li>
<li><p>算术运算 BINARY_ADD, BINARY_SUB, BINARY_MUL, BINARY_DIV, BINARY_MOD, BINARY_POW, </p>
</li>
<li><p>位运算 BINARY_SHIFT_LEFT, BINARY_SHIFT_RIGHT,</p>
</li>
<li><p>相等关系运算 BINARY_IS_EQUAL, BINARY_IS_NOT_EQUAL,</p>
</li>
<li><p>小于关系运算 BINARY_IS_SMALLER, BINARY_IS_SMALLER_OR_EQUAL, </p>
</li>
<li><p>等于运算 BINARY_IS_GREATER, BINARY_IS_GREATER_OR_EQUAL,</p>
</li>
<li><p>连接操作 BINARY_CONCAT, </p>
</li>
<li><p>其他(就是还不懂) BINARY_COALESCE,BINARY_IS_IDENTICAL, BINARY_IS_NOT_IDENTICAL, BINARY_SPACESHIP</p>
</li>
</ul>
<h2 id="AST-ASSIGN"><a href="#AST-ASSIGN" class="headerlink" title="AST_ASSIGN"></a>AST_ASSIGN</h2><p>另一个非常常见的两孩子点，就是赋值语句。当然， 左值和右值。</p>
<p> 数据流最爱连接的节点：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-090810.png" alt="截屏2020-07-14 下午5.07.42"></p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-090953.png" alt="截屏2020-07-14 下午5.09.18"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">foo</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>0child:左值(通常是变量)</li>
<li>1child: 右值(一波操作)</li>
</ul>
<p>追踪数据流变量在这一级上追踪。</p>
<h2 id="AST-ARRAY-ELEMENT"><a href="#AST-ARRAY-ELEMENT" class="headerlink" title="AST_ARRAY_ELEMENT"></a>AST_ARRAY_ELEMENT</h2><p><img src="/PHP-AST/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%889.26.11.png" alt="截屏2020-07-27 下午9.26.11"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span> =&gt; <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span> =&gt; <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>





<h1 id="3-child-nodes"><a href="#3-child-nodes" class="headerlink" title="3 child nodes"></a>3 child nodes</h1><h2 id="AST-METHOD-CALL"><a href="#AST-METHOD-CALL" class="headerlink" title="AST_METHOD_CALL"></a>AST_METHOD_CALL</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123118.png" alt="截屏2020-06-20 下午4.52.15"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stu</span>-&gt;<span class="title function_ invoke__">getScore</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>child0: var:stu &#x2F;&#x2F;比AST_CALL多一个对象名</li>
<li>child1: name: getScore </li>
<li>child2: args:math &#x2F;&#x2F;arg list</li>
</ul>
<h2 id="AST-STATIC-CALL"><a href="#AST-STATIC-CALL" class="headerlink" title="AST_STATIC_CALL"></a>AST_STATIC_CALL</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123122.png" alt="截屏2020-06-20 下午5.00.15"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu::<span class="title function_ invoke__">getScore</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>child0: class:stu （直接指向该类） </li>
<li>child1: name: getScore</li>
<li>child2: args: math</li>
</ul>
<h2 id="AST-CONDITIONAL"><a href="#AST-CONDITIONAL" class="headerlink" title="AST_CONDITIONAL"></a>AST_CONDITIONAL</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123125.png" alt="截屏2020-06-20 下午5.05.39"></p>
<h1 id="4-child-nodes"><a href="#4-child-nodes" class="headerlink" title="4 child nodes"></a>4 child nodes</h1><h2 id="AST-FOREACH"><a href="#AST-FOREACH" class="headerlink" title="AST_FOREACH"></a>AST_FOREACH</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123130.png" alt="截屏2020-06-20 下午3.42.11"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="variable">$k</span>.<span class="variable">$v</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>child0: expr: $arr</li>
<li>child1: keyVar: $k</li>
<li>child2: valueVar: $v</li>
<li>child3: stmts: 代码块list (ZEND_AST_STMT_LIST)</li>
</ul>
<h2 id="ZEND-AST-FOR"><a href="#ZEND-AST-FOR" class="headerlink" title="ZEND_AST_FOR"></a>ZEND_AST_FOR</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123134.png" alt="截屏2020-06-20 下午3.50.18"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;=<span class="number">1</span>; <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>child0: init: $i&#x3D;0</li>
<li>child1: condtion: $i&lt;&#x3D;1</li>
<li>child2: loop: $i++</li>
<li>child3:  代码块list (ZEND_AST_STMT_LIST)</li>
</ul>
<h1 id="list-nodes"><a href="#list-nodes" class="headerlink" title="list nodes"></a>list nodes</h1><p>AST_ARG_LIST &#x3D; 1    &#x2F;&#x2F;函数参数列表（实参）</p>
<p>AST_ARRAY &#x2F;&#x2F;数组成员列表</p>
<p><img src="/PHP-AST/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%889.26.11-5856522.png" alt="截屏2020-07-27 下午9.26.11"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span> =&gt; <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span> =&gt; <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>AST_EXPR_LIST</p>
<p>AST_STMT_LIST &#x2F;&#x2F;表达式块</p>
<p>AST_IF &#x2F;&#x2F;if判断条件列表</p>
<p>AST_SWITCH_LIST </p>
<p>AST_CATCH_LIST</p>
<p>AST_PARAM_LIST &#x2F;&#x2F;形参</p>
<p>AST_CLOSURE_USES</p>
<p>AST_PROP_DECL</p>
<p>AST_CONST_DECL</p>
<p>AST_CLASS_CONST</p>
<p>AST_NAME_LIST<br>AST_TRAIT_ADAPTATIONS<br>AST_USE<br>AST_TYPE_UNION<br>AST_ATTRIBUTE_LIST</p>
<h2 id="AST-STMT-LIST"><a href="#AST-STMT-LIST" class="headerlink" title="AST_STMT_LIST"></a>AST_STMT_LIST</h2><blockquote>
<p>最常见的块</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-093758.png" alt="截屏2020-07-14 下午5.30.15"></p>
<p>儿孙满堂， 一般从这个点跳到块中各个语句中。</p>
<h2 id="AST-IF-LIST"><a href="#AST-IF-LIST" class="headerlink" title="AST_IF_LIST"></a>AST_IF_LIST</h2><p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-093754.png" alt="截屏2020-07-14 下午5.14.28"></p>
<hr>
<p>一个分支结构的入口， 因为分支结构是不确定的， 所以是list，从这个点可以纵览分支结构有几个。一般不连控制流边(控制流边一般练到数据操作表达式点上如BINARY_OP，ASSIGN)。</p>
<p>下边的每一个分支入口，都是一个AST_IF（二元）:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AST_IF-&gt; <span class="number">0</span>child(AST_IF_ELEMENT0)</span><br><span class="line">       -&gt; <span class="number">1</span>child(AST_IFELEMENT1)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>child)&#123;</span><br><span class="line">  <span class="number">1</span>child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="number">0</span>child:<span class="literal">null</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">1</span>child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注: AST没有else节点，每个分支块都是一个AST_IF。</p>
<h1 id="declaration-nodes"><a href="#declaration-nodes" class="headerlink" title="declaration nodes"></a>declaration nodes</h1><p>声明式语句</p>
<table>
<thead>
<tr>
<th>&#x2F;* declaration nodes *&#x2F;</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ZEND_AST_FUNC_DECL</td>
<td></td>
</tr>
<tr>
<td>ZEND_AST_CLOSURE</td>
<td></td>
</tr>
<tr>
<td>ZEND_AST_METHOD</td>
<td></td>
</tr>
<tr>
<td>ZEND_AST_CLASS</td>
<td></td>
</tr>
<tr>
<td>ZEND_AST_ARROW_FUNC</td>
<td></td>
</tr>
</tbody></table>
<h2 id="控制流起始点："><a href="#控制流起始点：" class="headerlink" title="控制流起始点："></a>控制流起始点：</h2><ul>
<li>AST_CLASS</li>
<li>AST_FUNC</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/01/PHP-AST/" data-id="cl1d6sq92000dilw5ee7ig0e7" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-static-analysis-5-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/18/static-analysis-5-md/" class="article-date">
  <time class="dt-published" datetime="2020-05-18T12:33:55.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/18/static-analysis-5-md/">南大静态分析5(Data Flow Analysis - Foundations 1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>Iterative Algorithm, Another View    13:00</li>
<li>Partial Order 27:50</li>
<li>Upper and Lower Bounds 38:10</li>
<li>Lattice, Semilattice, Complete and Product Lattice 48:40</li>
<li>Data Flow Analysis Framework via Lattice 65:40</li>
<li>Monotonicity and Fixed Point Theorem 74:30</li>
</ol>
<hr>
<p><a target="_blank" rel="noopener" href="https://pascal-group.bitbucket.io/teaching.html">ppt</a></p>
<h1 id="1-Iterative-Algorithm-Another-View"><a href="#1-Iterative-Algorithm-Another-View" class="headerlink" title="1. Iterative Algorithm, Another View"></a>1. Iterative Algorithm, Another View</h1><blockquote>
<p>The general iterative  algorithm produces a solution to data flow analysis</p>
</blockquote>
 <img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.34.28.png" alt="截屏2020-05-30 上午8.34.28 " style="zoom:67%;" />

<p>这是通用的<code>Iterative Algorithm</code>， 思想是假设在一个程序生成的CFG之上，有<code>k</code>个节点，这个算法就会迭代的更新每一个OUT[n]（节点的out信息）。</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.38.10.png" alt="截屏2020-05-30 上午8.38.10 " style="zoom:70%;" />

<p>在值域<code>V</code>之上(就是我们待分析抽象出的domain)，那么可以定义一个<code>k-tuple</code> 他的每一个元素是每一个节点的OUT[n]，那么一次迭代分析 ，就是要更新这个集合中的值。</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.39.35.png" alt="截屏2020-05-30 上午8.39.35 " style="zoom:80%;" />

<p>那么每一次迭代处理就可以理解为在这个集合上，使用我们为了达成目的所设计transfer functions（program point处使用）和control-flow handing(汇合处使用)，来做更新(两种操作一个工作合称F来形式化表述)。F的输入输出为域(即上述集合) </p>
 <img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.45.46.png" alt="截屏2020-05-30 上午8.45.46 " style="zoom:60%;" />

<p>当F的输入输出不再变化(相同)，停止迭代。</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.51.52.png" alt="截屏2020-05-30 上午8.51.52 " style="zoom:60%;" />

<p>图示：</p>
<p><img src="/static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-05-30%20%E4%B8%8A%E5%8D%888.52.59.png" alt="截屏2020-05-30 上午8.52.59"></p>
<p>将算法分为了三个部分：</p>
<p>红色代表初始化：</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.47.18.png" alt="截屏2020-06-04 下午6.47.18 " style="zoom:33%;" />



<p>然后初始化每个位为bottom。进行迭代(绿色部分):</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.47.37.png" alt="截屏2020-06-04 下午6.47.37 " style="zoom:33%;" />

<p>每次更新状态，知道状态不再变化，符合了停止条件(黄色部分): </p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.47.40-1267695.png" alt="截屏2020-06-04 下午6.47.40 " style="zoom:33%;" />

<p>这里的i+1 与 i 的k-tuple值相同。</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.49.07.png" alt="截屏2020-06-04 下午6.49.07 " style="zoom:33%;" />

<p>(所以X是F的不动点, X&#x3D;F(X)（就像之前分析中，输入一个k-tuple(X)后不变了，算法停止）)</p>
<h1 id="2-Parial-Order"><a href="#2-Parial-Order" class="headerlink" title="2. Parial Order"></a>2. Parial Order</h1><p>首先定义偏序集：</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.51.34.png" alt="截屏2020-06-04 下午6.51.34 " style="zoom:50%;" />



<h3 id="偏序集："><a href="#偏序集：" class="headerlink" title="偏序集："></a>偏序集：</h3><blockquote>
<p>partial ordering就是一种偏序关系，可以理解为部分之间的关系(集合中不要求任何两个元素之间有关系)</p>
</blockquote>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.54.24.png" alt="截屏2020-06-04 下午6.54.24 " style="zoom:33%;" />

<p>这三个性质：</p>
<p>Reflexivity(自反性)：任意元素，关系可逆</p>
<p>Antisymmetrry(反对称性)： x偏序于y 且 y 偏序于x &#x3D;&gt; x&#x3D;y</p>
<p>Transitivity(传递性): …</p>
<blockquote>
<p>小于等于符号: 偏序关系。</p>
</blockquote>
<ul>
<li>例子一：</li>
</ul>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%886.59.24.png" alt="截屏2020-06-04 下午6.59.24 " style="zoom:33%;" />

<p>S这个set是一个整数集，他可不可以是一个p(偏序集)?</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.00.05.png" alt="截屏2020-06-04 下午7.00.05 " style="zoom:30%;" />

<p>由三条性质，是一个偏序集。</p>
<ul>
<li><p>例子二：</p>
<p>还是整数集set，但是偏序关系改成了小于：</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.01.38.png" alt="截屏2020-06-04 下午7.01.38 3" style="zoom:33%;" /></li>
</ul>
<p>不满足偏序关系。</p>
<ul>
<li>例子三：</li>
</ul>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.02.44.png" alt="截屏2020-06-04 下午7.02.44 " style="zoom:33%;" />

<p>字符型集合</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.03.26.png" alt="截屏2020-06-04 下午7.03.26 " style="zoom:33%;" />

<p>符合，上边文字在强调偏序(<code>partial</code>)的意义。</p>
<ul>
<li><p>例子四：</p>
<p>这个比较重要，每一个元素很想我们维持的状态抽象。然后箭头是控制流。。。<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.04.39.png" alt="截屏2020-06-04 下午7.04.39 " style="zoom:33%;" /></p>
</li>
</ul>
<h2 id="Upper-and-Lower-Bounds"><a href="#Upper-and-Lower-Bounds" class="headerlink" title="Upper and Lower Bounds"></a>Upper and Lower Bounds</h2><img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.51.49.png" alt="截屏2020-06-04 下午7.51.49 " style="zoom:33%;" />

<blockquote>
<p> upper bound 上界</p>
</blockquote>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.52.47.png" alt="截屏2020-06-04 下午7.52.47 " style="zoom:33%;" />

<p>偏序集合P中取一子集S，这一子集中任意元素都属于或者包含的(偏序于)。这是对于子集的一个定义，而upper bound 和 lower bound可以有多个， 定义<code>least upper bound</code>和<code>greatest lower bound</code></p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.57.04.png" alt="截屏2020-06-04 下午7.57.04 " style="zoom:30%;" />

<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.57.18.png" alt="截屏2020-06-04 下午7.57.18 " style="zoom:33%;" />

<p>譬如这个子集， 他的upper bound可以是{a, b}也可以是{a,b,c}</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.58.17.png" alt="截屏2020-06-04 下午7.58.17 " style="zoom:33%;" />

<p>一个符号表示：</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%887.58.39.png" alt="截屏2020-06-04 下午7.58.39 " style="zoom:30%;" />





<p>关于lub和glb的性质：</p>
<ol>
<li>不是每个偏序集都有<code>lub</code> or <code>glb</code></li>
</ol>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.01.17.png" alt="截屏2020-06-04 下午8.01.17 " style="zoom:33%;" />

<ol start="2">
<li>如果有，一定是唯一的</li>
</ol>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.01.40.png" alt="截屏2020-06-04 下午8.01.40 " style="zoom:33%;" />

<p>(证明： 如果有两个glb，根据glb的性质，有那个公式，然后再根据parital order的反对称性，那么就是他本身)</p>
<h1 id="Lattice"><a href="#Lattice" class="headerlink" title="Lattice"></a>Lattice</h1><img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.04.09.png" alt="截屏2020-06-04 下午8.04.09 " style="zoom:33%;" />

<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.04.14.png" alt="截屏2020-06-04 下午8.04.14 " style="zoom:33%;" />

<p>就是说如果一个偏序集的最大下界和最小上界都存在， 那么这就是一个Lattice。</p>
<ul>
<li>例子1:</li>
</ul>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.05.42.png" alt="截屏2020-06-04 下午8.05.42 " style="zoom:30%;" />

<p>这里我们去从整数集合中取一个子集(取集合就意味着划定了边界)。那么他会有glb和lub。</p>
<ul>
<li><p>例子2：</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.07.46.png" alt="截屏2020-06-04 下午8.07.46 " style="zoom:33%;" /></li>
</ul>
<p>这里的S就是所有的这些单词， 可以看到<code>pin </code>和<code>sin</code>没有上界。 虽是偏序集也就够不成一个格。</p>
<ul>
<li>例子3:</li>
</ul>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.09.28.png" alt="截屏2020-06-04 下午8.09.28 " style="zoom:33%;" />

<p>这玩意就是一个格</p>
<h2 id="Semilattice"><a href="#Semilattice" class="headerlink" title="Semilattice"></a>Semilattice</h2><p>半格， join半格(有最大下界)和meet半格(有最小上界)</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.10.49.png" alt="截屏2020-06-04 下午8.10.49 " style="zoom:33%;" />



<h2 id="Complete-Lattice"><a href="#Complete-Lattice" class="headerlink" title="Complete Lattice"></a>Complete Lattice</h2><img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.11.33.png" alt="截屏2020-06-04 下午8.11.33 " style="zoom:33%;" />

<p>比格的定义还要严格，格是要求偏序集中任意两个元素有最小上界和最大下界；全格要求任意两个<code>子集</code>有最小上界和最大下界。</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.15.03.png" alt="截屏2020-06-04 下午8.15.03 " style="zoom:33%;" />



<ul>
<li>例子1:</li>
</ul>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.16.30.png" alt="截屏2020-06-04 下午8.16.30 " style="zoom:33%;" />

<p>这里一个整数集合中，虽然任取两个数字是有边界的，但是任取两个子集不一定有边界，如正整数这个集合，他是正无穷的。</p>
<ul>
<li>例子2:</li>
</ul>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.19.46.png" alt="截屏2020-06-04 下午8.19.46 " style="zoom:33%;" />





<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.20.30.png" alt="截屏2020-06-04 下午8.20.30 " style="zoom:33%;" />

<p>每一个有穷的格，都是全格。</p>
<blockquote>
<p>数据流分析一般关注的都是全格，因为程序运行通常是有穷的</p>
</blockquote>
<h2 id="Product-Lattice"><a href="#Product-Lattice" class="headerlink" title="Product Lattice"></a>Product Lattice</h2><img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.22.21.png" alt="截屏2020-06-04 下午8.22.21 " style="zoom:33%;" />

 

<p>就像iterative algorithm中的k-tuple, 每一个点的L都是一个Lattice。那么整个Ln就是一个<code>Product Lattice</code></p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.26.04.png" alt="截屏2020-06-04 下午8.26.04 " style="zoom:33%;" />

<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.26.22.png" alt="截屏2020-06-04 下午8.26.22 " style="zoom:33%;" />





<p><img src="/static-analysis-5-md/2020-05-27-054002.jpg"></p>
<h1 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h1><p>将前边Lattice形式化的定义应用在<code>Data Flow Analysis</code>上</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.39.03.png" alt="截屏2020-06-04 下午8.39.03 " style="zoom:33%;" />

<blockquote>
<p>通用性的Data Flow Analysis 表示：</p>
<p>一个数据流分析， 需要根据需求设计以下三个方面</p>
<p>D:  沿着CFG的数据分析方向</p>
<p>L:  就是那个值域集合，用<code>Lattice</code> 来表示，实际中，在入口点，要么是并集<code>join </code>,要么是交集<code>meet</code>。(根据safe-approximate决定) （所以龙书用了半格?）</p>
<p>F：transfer functions， 每一个node都有自己的<code>transfer function</code></p>
</blockquote>
<p>例子： reach definition ：</p>
<ol>
<li>正向分析, 看到s1, s3的out分别是{a}, {b}, 分别体现在左边流图和右边格上对应的黄色区域。</li>
<li>Safe-approximate: join并集， 体现在绿色区域，在格上又上升了。</li>
<li>每个点转移函数后，生成out，在格上又上升了，到达上界。</li>
</ol>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.42.10.png" alt="截屏2020-06-04 下午8.42.10 " style="zoom:33%;" />

<blockquote>
<p>may analysis 在格上是往上升的</p>
</blockquote>
<p>一句话概括：</p>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.43.36.png" alt="截屏2020-06-04 下午8.43.36 " style="zoom:33%;"/>





<h2 id="Review-The-Questions"><a href="#Review-The-Questions" class="headerlink" title="Review The Questions"></a>Review The Questions</h2><img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-04%20%E4%B8%8B%E5%8D%888.45.01.png" alt="截屏2020-06-04 下午8.45.01 " style="zoom:30%;" />

<ol>
<li><p>算法一定能达到不动点吗？(lattice 上单调性问题)</p>
</li>
<li><p>如果有不动点，只能有一个动点吗</p>
</li>
<li><p>不定点是解吗</p>
<p>首先回答第一个问题：</p>
<img src="static-analysis-5-md/image-20210723223615852.png" alt="image-20210723223615852" style="zoom:40%;" />

<p>实际上回答一个lattic函数的单调性问题。</p>
</li>
</ol>
<h1 id="Monotonicity-amp-Fixed-Point-Theorem"><a href="#Monotonicity-amp-Fixed-Point-Theorem" class="headerlink" title="Monotonicity&amp;Fixed-Point Theorem"></a>Monotonicity&amp;Fixed-Point Theorem</h1><p>对于不动点定理的证明， 首先来看函数单调性的定义：</p>
<img src="static-analysis-5-md/image-20210723224024442.png" alt="image-20210723224024442" style="zoom:50%;" />



<blockquote>
<p>一个function在lattice（阈值）上是单调的，就是在域中任取x,y，都能够使得 x&lt;&#x3D;y &#x3D;&gt; f(x)&lt;&#x3D;f(y)。</p>
</blockquote>
<p>再来看不动点定理：</p>
<p>给定一个complete lattice如果：</p>
<ol>
<li><p>Lattice上的函数是单调的，</p>
</li>
<li><p>L是有限的(一个finite lattice一定是complete lattice; 一个complete lattice不一定是finite lattice)</p>
<p>那么我们能拿到，function迭代到不动点一定是最小不动点（或最大不动点）。</p>
<img src="static-analysis-5-md/image-20210724053026118.png" alt="image-20210724053026118" style="zoom:50%;" />





<p> 需要证明Fix point是存在的并且是最大(小)的不定点：</p>
<ol>
<li>证明不动点存在：</li>
</ol>
</li>
</ol>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-10%20%E4%B8%8B%E5%8D%888.50.46.png" alt="截屏2020-06-10 下午8.50.46 " style="zoom:50%;" />



<ul>
<li>因为f单调，f(bottom)也是lattice上的值，且bottom&lt;&#x3D;f(bottom)。(bottom最小)</li>
<li>f(bottom) &lt;&#x3D; f(f(bottom)) &#x3D; f^2(bottom)  (x&lt;&#x3D;y, f(x)&lt;&#x3D;f(y))</li>
<li>迭代…(上升链)</li>
<li>L是finite，所以肯定存在一个k值，(最差情况下走到top)，当f^k(bottom)&#x3D;f^k+1(bottom)那么就到达了不动点。(因为Lattic是finitie的, 就限制了上升(下降)链是finite的)</li>
</ul>
<ol start="2">
<li>证明Fix Point是最小(大)的:</li>
</ol>
<img src="static-analysis-5-md/%E6%88%AA%E5%B1%8F2020-06-10%20%E4%B8%8B%E5%8D%888.51.04.png" alt="截屏2020-06-10 下午8.51.04 " style="zoom:50%;" />



<p>假设存存在另外一个不动点x, 使得x &#x3D; f(x) （不动点定义），定义bottom, 我们有bottom&lt;&#x3D;x； </p>
<p>使用数学归纳法：</p>
<ul>
<li><p>初始条件: 因为f是单调的，f(bottom) &lt;&#x3D; f(x)</p>
</li>
<li><p>假设f^i(bottom) &lt;&#x3D; f^(x)，那么我们根据monotonic有： f^i+1(bottom) &lt;&#x3D; f^i+1(x).</p>
</li>
<li><p>得到结论： f^i(bottom)&lt;&#x3D;f^i(x)</p>
</li>
<li><p>因为f^i(bottom)&lt;&#x3D;f^i(x)&#x3D;x, 所以得: f^Fix &#x3D; f^k(bottom) &lt;&#x3D; x(从bottom走到第k次的不动点一定小于不动点x)</p>
</li>
</ul>
<p>将格上的数学证明关联到Iterative Algorithm，就可以证明我们的iterative algorithm是存在不动点且是最小(大)的了：</p>
<img src="static-analysis-5-md/image-20210724055841844.png" alt="image-20210724055841844" style="zoom:50%;" />



<p>下节课进行关联…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/18/static-analysis-5-md/" data-id="cl1d6sq9l001rilw5axed5m0x" data-title="南大静态分析5(Data Flow Analysis - Foundations 1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pl/" rel="tag">pl</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-static-analysis-4-2-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/17/static-analysis-4-2-md/" class="article-date">
  <time class="dt-published" datetime="2020-05-17T11:00:37.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/17/static-analysis-4-2-md/">南大静态分析-4(Avaliable Expressions Analsis)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Available-Expressions-Analysis-（可用表达式分析）"><a href="#Available-Expressions-Analysis-（可用表达式分析）" class="headerlink" title="Available Expressions Analysis （可用表达式分析）"></a>Available Expressions Analysis （可用表达式分析）</h1><blockquote>
<p>must analysis </p>
</blockquote>
<p>如果说一个表达式 <code>x op y </code> 在 program point <code>p</code> 上是available的，那么</p>
<ol>
<li>从流图入口点到点<code>p</code>的所有路径，都必须经过表达式<code>x op y</code>。(该表达式结点在流图上支配p点)</li>
<li>在上一次计算该表达式后， 没有再定义过x或者y</li>
</ol>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%888.16.00.png" alt="截屏2020-05-17 下午8.16.00 " style="zoom:50%;" />

<p>在程序优化中， 我们就可以在p出直接利用上一次的表达式计算结果来替换该表达式。也可以用来探测全域公共子表达式。</p>
<p>例子：</p>
<p>表达式可利用</p>
<img src="static-analysis-4-2-md/image-20201209145609833.png" alt="image-20201209145609833 " style="zoom:50%;" />

<p>表达式不可利用</p>
<img src="static-analysis-4-2-md/image-20201209145630745.png" alt="image-20201209145630745 " style="zoom:50%;" />



<h2 id="Abstraction-数据抽象"><a href="#Abstraction-数据抽象" class="headerlink" title="Abstraction(数据抽象)"></a>Abstraction(数据抽象)</h2><img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%888.16.43.png" alt="截屏2020-05-17 下午8.16.43 " style="zoom:70%;" />

<p>在流图中抽象每条表达式，可利用状态为一个位。0代表不可利用。 </p>
<h2 id="Safe-approximation"><a href="#Safe-approximation" class="headerlink" title="Safe-approximation"></a>Safe-approximation</h2><p>有了定义，有了抽象，下面就要进行评估-&gt;先看汇聚点怎么merge，再制定transfer function。</p>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.43.38.png" alt="截屏2020-05-17 下午9.43.38 " style="zoom:67%;" />



<p><img src="/static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.46.53.png" alt="截屏2020-05-17 下午9.46.53"></p>
<p>must analysis所有的path都要满足这一条件:</p>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.47.55.png" alt="截屏2020-05-17 下午9.47.55 " style="zoom:67%;" />

<p>是一种 under-approximation，可以有漏报，可以是safe的。</p>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.49.19.png" alt="截屏2020-05-17 下午9.49.19 " style="zoom:80%;" />

<p>这里如果b删了， 这里要做交。但是有情况，如x流下来时是<code>x=3</code>而恰好左边的BB中<code>x=3</code>。那么就是一个漏报。</p>
<h2 id="Algorithm-of-Available-Expressions-Analysis"><a href="#Algorithm-of-Available-Expressions-Analysis" class="headerlink" title="Algorithm of Available Expressions Analysis"></a>Algorithm of Available Expressions Analysis</h2><img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.51.13.png" alt="截屏2020-05-17 下午9.51.13 " style="zoom:67%;" />

<ul>
<li>正向分析， boundary是<code>OUT[entry]= 空</code>;</li>
<li>因为是must analysis,汇聚点做交，仅此<code>OUT[B] = U</code></li>
</ul>
<p>CASE:</p>
<p>初始化：</p>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.52.56.png" alt="截屏2020-05-17 下午9.52.56 " style="zoom:80%;" />

<p>第一次迭代：</p>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.53.57.png" alt="截屏2020-05-17 下午9.53.57 " style="zoom:80%;" />

<p>第二次迭代：</p>
<img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.54.44.png" alt="截屏2020-05-17 下午9.54.44 " style="zoom:80%;" />



<h1 id="总结三个算法"><a href="#总结三个算法" class="headerlink" title="总结三个算法"></a>总结三个算法</h1><img src="static-analysis-4-2-md/%E6%88%AA%E5%B1%8F2020-05-17%20%E4%B8%8B%E5%8D%889.56.10.png" alt="截屏2020-05-17 下午9.56.10 " style="zoom:80%;" />



<ul>
<li>设计一个数据流分析算法， 首先要描述场景， 从场景中抽象出我们需要的数据，然后设计<code>safe approximation</code>，转化成算法；还有就是理解算法是如何停止的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/17/static-analysis-4-2-md/" data-id="cl1d6sq9i001nilw5bd78h0v4" data-title="南大静态分析-4(Avaliable Expressions Analsis)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pl/" rel="tag">pl</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper/" rel="tag">paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pl/" rel="tag">pl</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/pl/" style="font-size: 20px;">pl</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/30/Hello/">Hello</a>
          </li>
        
          <li>
            <a href="/2022/02/24/web/">Web应用系中注入类漏洞调研</a>
          </li>
        
          <li>
            <a href="/2022/02/18/data-mining/">data_mining</a>
          </li>
        
          <li>
            <a href="/2022/02/14/pop/">A Survey about PHP Object Injection</a>
          </li>
        
          <li>
            <a href="/2022/02/06/logic-machine/">Logic Machine</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 iohex<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>