<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Penlab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Penlab">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Penlab">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="iohex">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Penlab" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Penlab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">The Art of Flow</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-loops" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/06/loops/" class="article-date">
  <time class="dt-published" datetime="2020-12-06T01:07:21.000Z" itemprop="datePublished">2020-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/06/loops/">程序分析之Loops in Flow Graphs</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>此文为编译原理(龙书)9.6章， 补充南大重续分析第6节之后。</p>
<h1 id="支配结点">1. 支配结点</h1>
<h2 id="定义">定义</h2>
<h3 id="支配结点-1">支配结点</h3>
<p>Dominators, 即支配结点， 如果从一段程序的entry point 到结点n的所有路径， 都经过结点m，那么我们就可以说m支配n，<code>记为 m dom n</code></p>
<p>支配结点性质：</p>
<ul>
<li>reflexive: a dom a （每个结点支配本身，不过为了区分的本身的支配结点也可以叫strict dom）</li>
<li>transitive: a dom b and b dom c =&gt; a dom c (具有传递性)</li>
<li>antisymmetric: a dom b and b dom a =&gt; a==b</li>
</ul>
<h3 id="直接支配结点">直接支配结点</h3>
<p>此外， 在到达一个结点的支配路径上的最后一个结点，记为<code>直接支配结点（immediate dominator）</code>， 如果一个结点记为n，他的直接支配结点记为m<code>(m idom n)</code>。在n的支配路径上，当支配结点不是自身时，支配节点d一定也支配m。</p>
<p>为啥要强调直接支配呢？要看我们表示流图中支配关系的数据结构： 支配树</p>
<h3 id="支配树">支配树</h3>
<p>首先，手工来找每一个支配结点的支配对象。此处我们的入口结点是1号结点， 我们可以看到，1号结点支配所有结点， 而2号结点在1号结点的分支上，下层所有结点都可以从3号结点到达， 因此2号结点仅支配它自身(任何结点都支配自身)。 如图，以此类推。如此生成一颗支配结点树。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125517.png" alt="image-20201208181751573 " style="zoom:20%;" /></p>
<p>这颗树上，入口为程序根结点，每个结点支配它的后代结点：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125520.png" alt="image-20201208182015843 " style="zoom:30%;" /></p>
<p>生成树的性质：</p>
<ul>
<li><p>顶点： 程序入口点</p></li>
<li><p>边： 直接支配结点</p></li>
<li><p>路径： 所有支配路径</p></li>
</ul>
<h2 id="支配路径分析算法">支配路径分析算法</h2>
<p>要设计一个算法，来求出一段程序中每个结点的支配路径。 那么整个算法的思想如下：</p>
<blockquote>
<p>如果p1,p2,p3....pk是结点n的所有前驱， 并且d不等于n, 那么当且仅当每个d dom pi时(pi为每个p)，d dom n。</p>
</blockquote>
<p>也就是说，n的一个前驱结点如果要是称为n的支配结点d，那么必须支配到达n点的所有前驱。因此他表示成的数据结构也就是一棵树(回溯祖先只有一条路经)。</p>
<p>比如上面的程序流图中，4到8点之间有5，6，7三个点， 4号结点同时支配5,6,7,因此4号结点支配8号结点；而5号结点到8号结点之间有7号结点， 5号结点并不支配7号结点(他只支配本身)， 因此5号结点并不能支配8号结点。</p>
<p>好算法原理介绍完了，接下来我们设计这个程序分析。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125523.png" alt="截屏2020-05-17 下午9.56.10 " style="zoom:80%;" /></p>
<p>对照这张表，分析次算法。</p>
<ul>
<li><p>Domain: 基于抽象的数据集， 应该选择所有点</p></li>
<li><p>Direction: 求每个程序点的支配路径，Forwards更直观</p></li>
<li><p>May/Must: 为了保证我们的分析结果safe，那么这应该是一个must-approximation，以确保支配路径的唯一性。</p></li>
<li><p>Boundary: 边界条件，由于是前向的，Must分析， 那么程序的边界应该是OUT[entry]， 从上到下，而初始应该不是空集，而是本结点为支配结点(入口结点是所有结点的支配结点)，即OUT[entry] = {entry}</p></li>
<li><p>Initialization: 因为Meet是交运算，每个程序结点的初始化应该是所有路径OUT[B]=N(假设所有结点都是他的支配结点)</p></li>
<li><p>Transfer funciton: 每个基本块内的转移函数，因为是前向分析，所以转移函数应该IN[B]union上本身{B}。F(x) = xU{B}</p></li>
<li><p>在merge处(程序数据的合并点)我们取交集。</p></li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125527.png" alt="image-20201206101945309 " style="zoom:67%;" /></p>
<p>这个算法的Transfer function和之前的-kill +gen的不同， 需要注意。</p>
<p>拿来那张Must分析的图：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125530.png" alt="截屏2020-08-13 上午8.54.34 " style="zoom:67%;" /></p>
<p>初始时所有前驱点都是支配结点，然后将这个集合不断缩小知道最大不动点，求最大下界。</p>
<p>因此我们的Iterative Algorithm有：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125533.png" alt="image-20201206102844236 " style="zoom:50%;" /></p>
<p>来看具体的例子：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125536.png" alt="image-20201206104654556 " style="zoom:50%;" /></p>
<p>D(n)是所有结点的支配结点的集合。</p>
<p>D(1)是入口结点， 支配结点就是它本身。</p>
<p>D(2)中的转移函数回吧IN[B]即D(1)union上自身{2} =&gt; {1,2}</p>
<p>D(3)同理， 转移函数{3}unionIN[B]，这里的IN[B]是有四条边， 根据merge取并集，我们有D(1)nD(2)nD(4)nD(8)因为4，8没有分析，所以他们的OUT[B]都是初始值，所有点。因此D3 = {1,3}。</p>
<p>停止条件：</p>
<p>因为我们的OUT[B]=IN[B]union本身，我们看第一次迭代后，其实已经达到了不动点。比如D(3)在第二次迭代时，D(1)是恒不变的，D(2)就是不变的。此时D(4) = {1,3,4}, D(8) = {1,3,4,7,8} 他们的并集一定是小于等于4的结点集合,即{1,3,4}，而只要有前驱1,2在，那么支配结点的并集就一定是小于3的。(不考虑环路)</p>
<p>如果不考虑环路了， 那么在无环图上，根据支配结点的性质， <code>除了入口结点，每一个结点都有唯一的直接支配结点</code>。再比如4号结点，有3和7两个入边，要证明停止， 我们就要证明7号的支配结点一定包含{1,3}而不会再包含2，那么算法就停止了。也就是说只计算一次，路径中的所有支配结点都出现了，不会再添加其他的了。如果再添加了2，即{1,2,3}那么程序中到达4就会有两条路经，1，3，4和1，2，3，4。</p>
<p>如此一来， 算法变成了：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125539.png" alt="image-20201206113136795 " style="zoom:50%;" /></p>
<p>没有了while循环。</p>
<h1 id="深度优先生成树">2. 深度优先生成树</h1>
<p>我们需要分析循环XD，现在，我们根据支配路径分析算法， 得到了生成树，也就是说得到了流图上每一个点的支配路径信息。而实际控制流图所走的路径中间夹杂着支配结点之外的结点。此外，要在流图中刻画循环，我们需要知道流图中什么时候前进，什么时候回退了。这些信息需要生成一个深度优先生成树来提供。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125542.png" alt="image-20201207105042417 " style="zoom:70%;" /></p>
<p>要在流图上进行深度优先搜索所得到的序列: 1,2,3,4,5,6,7,8,9,10 。我们可以生成深度优先生成树， 这棵树的后序遍历序列(10,9,8,7,6,5,4,3,2,1)之反就是我们所需的序列。</p>
<p>实现这个算法：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125545.png" alt="image-20201207105419198 " style="zoom:30%;" /></p>
<p>具体算法：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125549.png" alt="image-20201207105454286 " style="zoom:60%;" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dfst</span></span><br><span class="line"><span class="string">～～～～</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">_visit = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">_graph = &#123;</span><br><span class="line">        <span class="number">1</span>: [<span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">        <span class="number">2</span>: [<span class="number">3</span>],</span><br><span class="line">        <span class="number">3</span>: [<span class="number">4</span>],</span><br><span class="line">        <span class="number">4</span>: [<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>],</span><br><span class="line">        <span class="number">5</span>: [<span class="number">7</span>],</span><br><span class="line">        <span class="number">6</span>: [<span class="number">7</span>],</span><br><span class="line">        <span class="number">7</span>: [<span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">        <span class="number">8</span>: [<span class="number">10</span>, <span class="number">9</span>],</span><br><span class="line">        <span class="number">9</span>: [<span class="number">1</span>],</span><br><span class="line">        <span class="number">10</span>: [<span class="number">7</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">_c = <span class="built_in">len</span>(_graph)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">n</span>):</span><br><span class="line">    _visit.add(n)</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> _graph[n]:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> _visit:</span><br><span class="line">            search(s)</span><br><span class="line">    <span class="keyword">global</span> _c</span><br><span class="line">    _c = _c -<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_c = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(_c))</span><br><span class="line"></span><br><span class="line">search(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">output=&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">_c=<span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">_c=<span class="number">8</span></span><br><span class="line">_c=<span class="number">7</span></span><br><span class="line">_c=<span class="number">6</span></span><br><span class="line">_c=<span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">_c=<span class="number">4</span></span><br><span class="line">_c=<span class="number">3</span></span><br><span class="line">_c=<span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">_c=<span class="number">1</span></span><br><span class="line">_c=<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如此一来可以看到：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125552.png" alt="image-20201208100007943" style="zoom:50%;" /></p>
<p>图中流图的边可以分为三种：</p>
<p>1） 实线边，即深度优先生成树算法生成的边，也就是<code>前进边(Advancing edge)</code>，这些边推进流图向下执行。</p>
<ol start="2" type="1">
<li>虚线边中从子节点指向其祖先的，也就是<code>后退边(Retreating edge)</code>，这些边指向上层。</li>
</ol>
<p>3）另外一些虚线边(5-&gt;7, 2-&gt;3)，这些边互相都不为祖先。也即是<code>交叉边(cross edge)</code>。</p>
<h1 id="自然循环">3. 自然循环</h1>
<h2 id="回边">回边</h2>
<p>给了一个流图， 要对循环进行分析。首先，我们定义了支配结点这一二元关系。然后通过直接支配结点，我们构建了一颗深度优先生成树，在这颗树上，顶点就是程序入口点，边就是直接支配关系，所有的路径就是所有的支配路径。有了这层关系，我们在树上不上了虚边，在后退边中，我们现在定义一种回边。这种回边一定是后退边(但是后退边不一定是回边)。回边的定义是这样的如果1 dom 9 现在有一条边，他的头是9，尾是1那么也就是说尾支配了头，这就是一条回边。</p>
<p>上边说了，后退边不一定是回边，如：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125600.png" alt="image-20201208174753377" style="zoom:60%;" /></p>
<p>这是鲸书第七章的一个例子。从流图a中我们可以看到c和d的流形成一个环路， 但是他生成的任意一种深度优先生成树(或de在前或c在前)。都有一条后退边，指向一个他的非支配结点。</p>
<blockquote>
<p>因为我们在第一步计算了一个结点的所有支配对象，在第二步计算出了流图的深度优先生成树。那么我们就可以拿到所有支配路径，以及支配路径上所有结点的支配结点信息。通过生成树，我们就可以知道流图上那一些边是后退边，通过支配结点的计算，我们就可以知道后退边指向的是不是支配他的结点，从而判断一条后退边是不是回边。</p>
</blockquote>
<h2 id="自然循环-1">自然循环</h2>
<p>如果一个流图中，他的每一种深度优先生成树中所有后退边都是回边，那么这张流图就是 <code>可规约的（reducible）</code>，此时他每一种遍历情况下生成的深度优先生成树的所有后退边的集合，都是相同的。</p>
<h3 id="自然循环定义">自然循环定义：</h3>
<ul>
<li>必须具有一个唯一的入口结点， 称为循环头(header)。</li>
<li>具有一条进入循环头的回边。</li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125611.png" alt="image-20201208204910207 " style="zoom:30%;" /></p>
<p>在此图中可以看到， 在流图中找自然循环， 首先，找出所有回边。</p>
<p>然后如4-3: 这歌循环中3号结点为循环头，找到所有不经过3而到达4的结点：</p>
<p>4， 5，6，7，8，10。 然后再加上循环头3就是这个自然循环的组成。</p>
<h3 id="构造一条回边的自然循环">构造一条回边的自然循环：</h3>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125617.png" alt="image-20201208205823633 " style="zoom:33%;" /></p>
<p>算法说明一下，注意两点，一是n初始的时候已经在Loop中了， 二是找的是栈顶指针的前驱，弹出后，有前驱再压栈。比如还是在4-3的自然循环中，我们第一次循环压入了4， 然后找到了前驱m=[3,8], 3是循环头不过if, 因此8被压栈；下一轮8出栈，7入栈；再一轮7出栈，5、6、10入栈。。。</p>
<blockquote>
<p>所以说这里就是以循环头为上界进行一个流图的反向深度遍历。</p>
</blockquote>
<h3 id="自然循环性质">自然循环性质</h3>
<ul>
<li>除非两个循环有相同的循环头， 否则他们要不分离，要么嵌套。</li>
<li>一个循环不包含其他循环称为最内层循环(innermost loop)/同理流图中包含所有循环的是最外循环</li>
<li>下图中包含同一个循环头，很难说哪一个是最内循环(可能是循环中的if...else)，因此合并循环</li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125622.png" alt="image-20201208211513630 " style="zoom:30%;" /></p>
<h1 id="后记-循环优化">后记： 循环优化</h1>
<p>补充虎书第18章循环优化的内容</p>
<h2 id="loop-nest-tree">Loop-nest Tree</h2>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/06/loops/" data-id="cl1q2wlhs000q47w577x6efxf" data-title="程序分析之Loops in Flow Graphs" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PHP-Static-Analysis-Theory" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/14/PHP-Static-Analysis-Theory/" class="article-date">
  <time class="dt-published" datetime="2020-11-14T03:15:48.000Z" itemprop="datePublished">2020-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/14/PHP-Static-Analysis-Theory/">Static Detection of Security Vulnerabilities in Scripting Languages</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="static-detection-of-security-vulnerabilities-in-scripting-languages">Static Detection of Security Vulnerabilities in Scripting Languages</h1>
<p>本文为Stanford大学2005年发表的文章追本溯源，这个Yichen Xie和Alex Aiken团队似乎是PHP安全静态分析比较早的，那个时候，台大的Huang等的WebSSARI应该出来了； Livshits等的Pixy也在构建中。 这一篇理论性的东西比较多，都是在构建数学模型，有借鉴意义。 再拿来总结一下。</p>
<p>本文提出的是一个PHP安全漏洞的静态分析算法， 他们提出了一种三层架构从块内，过程内， 过程间三个级别进行静态分析。 尝试解决脚本语言独有的一些的动态特性，如动态类型， 代码包含。</p>
<h2 id="贡献">贡献</h2>
<ul>
<li><p>提出了一个对于PHP的过程间静态分析算法。 尝试解决一些动态语言特有的挑战， 如： 动态代码加载， 动态变量类型转化， pervasive use of hash tables and regular expression matching.</p>
<p>如上所说， 本文的核心方法时提出了一种三层结构， 利用隔离处理，想上传播的思想。 在<code>intrablock</code>, <code>intraprocedural</code>, and <code>interprocedual</code>三个level上做文章。 如在每个BB（basic block）中， 作者尝试利用符号执行去model动态特征(dynamic features)， 然后将结果生成block summaries, 这些summaries供上层分析使用， 从而帮助我们hidden了下层内部的复杂结构。</p></li>
<li><p>本文使用上述静态分析方法寻找SQL注入， 但是we believe that, with small modifications, the same techniques can be applied to detecting other vulnerabilities such as XSS and code injection in web applications.</p></li>
<li><p>本文experimentally validate our approach by implementing the analysisi algorithm and running it on 6 popular web application written in PHP. 找到了105个0day.</p></li>
</ul>
<h2 id="scripting-language-dynamic-feautres">Scripting Language Dynamic Feautres</h2>
<p>每次遇到这个章节， 我都想总结一下:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130127.png" alt="image-20210711161321077 " style="zoom:40%;" /></p>
<p>如上例子， 作者对比了PHP与JAVA构造SQL语句时的不同，JAVA用的是prepared statements(当然PHP引入PDO后也是这样，但是int类型还是会出问题)。而PHP直接拼接字符串(<code>natural integration</code>)。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130130.png" alt="image-20210711161557125" style="zoom:40%;" /></p>
<p><code>implicit casting</code> 主要涉及到字符串,这种web app中最常见的输入。 在代码中常常做出各种诡异的转化。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130134.png" alt="image-20210711161827521" style="zoom:40%;" /></p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130136.png" alt="image-20210711162140830" style="zoom:40%;" /></p>
<p>如使用，<code>extract</code>会根据参数讲数组的键值映射成变量，(这一块没太看清楚,可能就是讲extract这种函数动态向符号表引入变量)。</p>
<h2 id="analysis">ANALYSIS</h2>
<p>本文主要的贡献是还是一些理论上的形式化分析， 没有看到工程上的东西。</p>
<h3 id="步骤">步骤：</h3>
<ol type="1">
<li>生成AST</li>
</ol>
<p>AST: 将PHP解析成抽象语法树(用的PHP5.0.5)， 还是以文件为单位的， 将文件中无封装的无的语句作为main function, 每一个文件有一个main, 0-N个user-defined function, 分析从main function开始。</p>
<ol start="2" type="1">
<li>建BB，建CFG</li>
</ol>
<p>分析文件中的每个function的ast。 划分BB,本文用的粒度是<code>single entry, single exit sequences of tatements</code>(看到还有以单条statement为粒度的)。然后构建CFG，遇到conditional jumps在CFG edge上label branch predicate。</p>
<ol start="3" type="1">
<li><p>Simulated using Symbol execution</p>
<p>对每一个基本块， 作者使用了动态特性去理解块中的每一条statement对global state of the program所带来的影响，并将这些信息记录成summary。</p></li>
<li><p>Reachability analysis</p>
<p>即数据流的可达性分析， 建立在构造好summaries的块之上，combine <code>block summaries</code> into a <code>function summary</code> , 此时function summary建立了(即第二层)，每个<code>function summary</code> 描述了<code>pre- and post-conditions of a function</code></p></li>
<li><p>处理calls</p>
<p>在function内做可达性分析时， 难免会遇到其他过程的调用，此时需cover。</p></li>
</ol>
<p>具体来看：</p>
<h2 id="simulate-basic">1. Simulate Basic</h2>
<p>在语言建模的基础上，完成转化，生成每个块的summary（BlockSummary）</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130155.png" alt="image-20201114140707691 " style="zoom:50%;" /></p>
<p>这个总的算法，输入为一个基本块，初始一个<code>state</code> 用来初始化块中变量状态(<code>x</code>-&gt;<code>x0</code>) 。 并在循环中迭代更新状态，如果遇到return和exit，则为出口；end block（迭代完成）也为出口，过程间分析时遇到<code>exit</code>也为出口。用每一个基本块的simulate后的state做一个summary, 然后返回这个块的summary。</p>
<p><code>intra-block simulation</code>的关键 问题就是在于如何simulate state， 以下讨论<code>simulation process</code>:</p>
<p>## Language： 先对语言进行建模</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130158.png" alt="image-20201114142327873 " style="zoom:50%;" /></p>
<p>在此作者根据需求， 对PHP语言进行建模， 形成了一个子集：</p>
<ol type="1">
<li><p>变量值类型(Value Type): 字符，布尔，数组，静态无法确认的数据(如形参)</p></li>
<li><p>常量值类型(Constant): 字符串，数字，true, false, null</p></li>
<li><p>L-val(location value)，这里有variable x, 实参，array</p></li>
<li><p>表达式(Expression)：常量表达式，变量表达式， 二元操作表达式， 一元操作表达式， 表达式类型转化。</p></li>
<li><p>语句(Statement): 赋值语句(表达式运算)，赋值语句(过程调用) ，返回值语句return, 退出语句exit，包含语句include。</p>
<p>其中提到了，include这种statement是scripting language所特有的(which allows prorammers to dynamically insert code into the program)。</p></li>
</ol>
<h2 id="simulation-statememory-location---value">Simulation State(Memory Location -&gt; Value)</h2>
<p><code>Simulation State</code> 是一个映射， 此映射: Memory Location-&gt;their value representations, 此处的<code>memory location</code> 指的是一个<code>program variable</code>(e.g., x), 或者<code>a hash table accessed via another location</code>（e.g. x[key]).</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130211.png" alt="image-20210713163228163" style="zoom:50%;" /></p>
<blockquote>
<p>The simulation state maps memory locations to their value representations</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130214.png" alt="image-20210715164509813" style="zoom:50%;" /></p>
</blockquote>
<p>图(a)是完整的表述。这一段就是形成一个Location到value的映射。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130217.png" alt="image-20201114145427950 " style="zoom:50%;" /></p>
<p>在开始分析的时候， Loc会被初始化为一个<code>L0</code>, 组成了simulation的初始状态集合。然后迭代value， 这里的value分为三类，具体看图(a)中的value representation部分，可以表示为三类分别是(String, Boolean和Integer)。</p>
<ul>
<li><p>String:</p>
<p>String是最基本的类型，也是我们关注的类型。modeling string 的精确程度，直接影响了分析的精确性。</p>
<p>作者认为，<code>modeling concatenation well enables an analysis to better understand information flow in a script</code>. 举例子来说，就像用户输入的GET, POST会拿来拼接SQL语句，SQL查询结果又会拼接到HTML中， 这是常见的动态web操作。因此，作者将<code>string values are represented as an ordered concatenation of string segments,.</code></p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130220.png" alt="image-20210713162322867" style="zoom:67%;" /></p></li>
<li><p>Boolean:</p></li>
<li><p>Integer:</p>
<p>Support track integer constants and binary and unary operations between them. We also support type cast from integers to Boolean and string values.</p></li>
</ul>
<h3 id="locations和l-val转化规则">Locations和L-val转化规则</h3>
<p>这里在解释L-val, 首先看模型：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130223.png" alt="image-20201114152059860 " style="zoom:50%;" /></p>
<p>如上面对Lv的规则的定义， var, arg,dim三种(注意当时的文章都不考虑OO)。</p>
<p>看下边这个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hash</span> = <span class="variable">$_POST</span>; <span class="comment">//$_POST这个hash table赋给$hash</span></span><br><span class="line"><span class="variable">$key</span> = <span class="string">&quot;user&quot;</span>; <span class="comment">//常量赋值</span></span><br><span class="line"><span class="variable">$userid</span> = <span class="variable">$hash</span>[<span class="variable">$key</span>]; </span><br></pre></td></tr></table></figure>
<p>分析这段代码， 首先看初始状态</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130227.png" alt="image-20201114152915770 " style="zoom:50%;" /></p>
<p>我们让每一个符号指向一个初始状态。然后根据上边的规则定义， 根据var的规则处理前两条：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130231.png" alt="image-20201114153406937 " style="zoom:50%;" /></p>
<p>他们都指向了一个unique location。</p>
<p>第三条来用dim的规则定义处理。此时根据横线上方两条条件规则(e是名e'是键)，分别映射到_POST0和['userid']那么他将映射到L[阿尔法]中， 即_POST[userid]0。</p>
<hr />
<h3 id="exp转化规则">Exp转化规则</h3>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130234.png" alt="image-20201114154757715 " style="zoom:50%;" /></p>
<p>因为脚本语言是一种动态类型， 在运行解释器会选择当前运算最适合的规则(弱类型)。那么就带了了类型转化问题。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130236.png" alt="image-20201114154900851 " style="zoom:50%;" /></p>
<hr />
<h3 id="statements转化规则">Statements转化规则</h3>
<p>赋值有两种： 表达式计算赋值，和过程间调用赋值。 先看表达式计算如何被model:</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130240.png" alt="image-20210715171024725" /><figcaption aria-hidden="true">image-20210715171024725</figcaption>
</figure>
<p>Assignment rule：</p>
<ol type="1">
<li>resolves the left-hand side into a memory location l. (上式lv=&gt;l)</li>
<li>evaluates the right-hand side into a value v.(上式e=&gt;v)</li>
</ol>
<p>然后根据rule update the simulation state after the assignment maps <code>l</code> to the new value <code>v</code>。</p>
<hr />
<h3 id="block-summary">Block summary</h3>
<p>经过以上的转化后， 将块内信息转化为block summary，一个块summary是由六元组组成:</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130243.png" alt="image-20210719203339317" /><figcaption aria-hidden="true">image-20210719203339317</figcaption>
</figure>
<ul>
<li><p>Error set: 在进入BB时，每一个variables必须是sanitized的状态。</p></li>
<li><p>Definitions: the set of memory locations defined in the current block.</p></li>
<li><p>Value flow: the set of pairs of locations (l1, l2), l1 on the entry becomes a substring of l2 on exit.</p></li>
<li><p>Termination predicate: 块中是否含有程序终结, true if the current block contains a exit statement, or if it calls a function that causes the progmra to terminate.</p></li>
<li><p>Return value: 返回值， records the representation for the return value if any, undefined otherwise.</p></li>
<li><p>Untaint set: 向每个后继块传递当前的未过滤变量集合(由于有分支的存在，故每一个后继得到的summary可能不同)</p></li>
</ul>
<h3 id="intraprocedural-analysis">Intraprocedural Analysis</h3>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130248.png" alt="image-20210719204831765" /><figcaption aria-hidden="true">image-20210719204831765</figcaption>
</figure>
<p>一个过程内的抽象，是基于他的块抽象的：</p>
<ul>
<li>Error set: the set of <code>memory locations(variables, parameters, and hash access)</code>, 因为查的是SQL注入， 所以当其中一个memory locations的value流入database query时， 必须有记录他被sanitized了,否则error</li>
<li>Return set: the set of parameters or global variables 进入了return value（only string）</li>
<li>Sanitized values: the set of parameters or global variables,使用前向数据流可达性分析来探测被过滤输入流入每一个包含return的块。</li>
<li>Program Exit: 一个指明当前function是否退出程序， 穷举所有CFG可达块。 如果没有return, 此程序就是一个exit function(也不一定，有的分支执行到最后就默认返回null了)</li>
</ul>
<h3 id="interprocedural-analysis">Interprocedural Analysis</h3>
<p>本文的分层次污点分析的最高层， interprocedural层。分析intra的summary, 对于每一个function call点， f(e1...en)分析一下四个方面：</p>
<ul>
<li><p>Pre-conditions: 使用error set 证明the set of parameters and global variables在进入该过程时都是安全的</p></li>
<li><p>Exit condition: 如果进入了一个exit function, 就将之后所有的stmt删除。</p></li>
<li><p>Post-conditions:</p></li>
<li><p>Return value:</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130251.png" alt="image-20210719210926117" /><figcaption aria-hidden="true">image-20210719210926117</figcaption>
</figure></li>
</ul>
<figure>
<img src="PHP-Static-Analysis-Theory/image-20210719210938703.png" alt="image-20210719210938703" /><figcaption aria-hidden="true">image-20210719210938703</figcaption>
</figure>
<h2 id="experimental-results">ExPERIMENTAL RESULTS</h2>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130253.png" alt="image-20210719211022777" /><figcaption aria-hidden="true">image-20210719211022777</figcaption>
</figure>
<p>没有 False Positive, 确定没有误报？</p>
<h2 id="case-study">CASE STUDY</h2>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-130258.png" alt="image-20210719211058506" /><figcaption aria-hidden="true">image-20210719211058506</figcaption>
</figure>
<p>但是我并没有看到具体的符号执行啊。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/14/PHP-Static-Analysis-Theory/" data-id="cl1q2wlhk000947w53nd40q7j" data-title="Static Detection of Security Vulnerabilities in Scripting Languages" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper/" rel="tag">paper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-NDSS-14-RIPS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/01/NDSS-14-RIPS/" class="article-date">
  <time class="dt-published" datetime="2020-11-01T07:24:12.000Z" itemprop="datePublished">2020-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/01/NDSS-14-RIPS/">Simulation of Built-in PHP Feature for Precise Static Code Analysis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>文章题目： Simulation of Built-in PHP Feature for Precise Static Code Analysis.</p>
<p>作者： Johannes Dahse &amp; Toorstem Holz</p>
<p>RIPS研究PHP静态分析几乎绕不开的工具， 一是选择的时间点好，2014年左右PHP还是比较火的。二是工具确实不多。 这篇文章发了14年的NDSS，还是有些东西值得借鉴的。</p>
<h2 id="技术背景">技术背景</h2>
<p>首先， 作者在技术背景部分分析了一些PHP这种highly dynamic lanuage的痛点。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125738.png" alt="image-20201101153514155" style="zoom: 25%;" /></p>
<ul>
<li><p>1） 动态类型/弱类型</p>
<p>脚本语言在变量声明时不用声明类型的确给静态分析带来不少麻烦，而动态类型指的是在运行时类型是可以变得(its variables are not bound to a specific data type).</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var1</span> = <span class="number">1</span>; <span class="variable">$var2</span> = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="variable">$var2</span> = <span class="variable">$var1</span> + <span class="variable">$var2</span>; <span class="comment">//1 </span></span><br></pre></td></tr></table></figure></li>
<li><ol start="2" type="1">
<li>variable Variables</li>
</ol>
<p>这个貌似是PHP独有的，叫$$特性？</p>
<p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="string">&quot;x&quot;</span>;</span><br><span class="line"><span class="variable">$x</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$$name</span>; <span class="comment">//test</span></span><br><span class="line"><span class="variable">$y</span> = $&#123;<span class="title function_ invoke__">getVar</span>()&#125;; <span class="comment">//变量名可以是一个表达式ZZ</span></span><br></pre></td></tr></table></figure></p></li>
<li><ol start="3" type="1">
<li><p>Dynamic Arrays</p>
<p>动态数组，PHP的数组是hash table实现的。可以存任何不同的数据类型，而且在初始化的时候key值可以省略在运行时指定。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125750.png" alt="image-20201101154933544" style="zoom: 50%;" /></p></li>
</ol></li>
</ul>
<p>注意这里新添加的自动索引了6, 神不神奇？会按照“4”开始算，把"4"改成"664"就是'e'的索引就是666。（还是说脚本语言的不规范性）</p>
<ul>
<li><ol start="4" type="1">
<li><p>Dynamic Constants</p>
<p>通过define()在于形式动态定一个常量， 通过constant()运行时访问。</p></li>
</ol></li>
<li><ol start="5" type="1">
<li>Dynamic Function</li>
</ol>
<p>function动态调用， 这个说的就太多了。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125752.png" alt="image-20201101155917397" style="zoom:50%;" /></p></li>
</ul>
<p>第2行向我们讲述了， 不仅变量名可以是表达式， 方法名也可以是表达式； 第三行是一个回调函数，在动态的时候才知道执行啥。另外，还有<code>fun_get_arg()</code>和<code>func_get_args()</code>在运行时动态从call site拿参数; <code>create_function()</code>动态创建一个方法体org。</p>
<ul>
<li><ol start="6" type="1">
<li><p>Dynamic Code</p>
<p>动态执行代码， 通过<code>eval</code>, <code>assert</code>，小马常用到。这些代码在动态运行时才能知道， 给静态分析增加了难度。</p></li>
</ol></li>
<li><ol start="7" type="1">
<li><p>Dynamic includes</p>
<p>这个吐糟也比较多， 大型PHP项目尝尝被分割成若干文件和目录，他们的拼接为静态分析也增加了难度。类似<code>include</code>，使用这种操作，将文件中的代码返回到include处。尤其是现在又加了惰性加载机制。autoload()这种在静态分析目前只有猜了。</p></li>
</ol></li>
<li><ol start="8" type="1">
<li>Built-in Functinos</li>
</ol>
本文关注和要解决的主要challenge。不像Java, PHP的内建函数都是用C写的， 在ZEND执行时调用。大约有228个扩展5701个内建函数， 他们在静态分析PHP代码时无法被hook到，这就导致了分析的不精确。</li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125756.png" alt="image-20201101162437988" style="zoom:50%;" /></p>
<p>如图，第二个位置月份可以是字符型， 这里如果要能探测到XSS就要对list(), printf()进行精确建模。</p>
<ul>
<li><ol start="9" type="1">
<li><p>Superglobals</p>
<p>我们的超全局变量， 需要精确的标明哪些可控。开发者经常忽略FILES和SERVER的安全性。</p></li>
</ol></li>
</ul>
<h2 id="方法设计">方法设计</h2>
<h3 id="纵览">纵览</h3>
<ol type="1">
<li><p>还是文件为单位， 首相将散乱在文件中的代码解析成main AST(脚本语言通常没有main方法做入口)， 然后将user-defined function们收集起来， 将函数名， 参数等信息存入分析环境， 然后将其函数体构建成separate AST独立于main AST。</p></li>
<li><p>有了 AST， 下一步构建CFG(控制流图)， 分析AST如果发现<code>conditional jump</code> , 就开辟一个新的基本块(<code>basic block</code>);并使用<code>basic edge</code>相连接。</p></li>
<li><p>有了CFG， 下一步构建PDG(数据依赖图)咯， 以基本块为单位，每当一个BB产生， 就分析一下他的<code>adta flow</code> 。</p></li>
<li><p>实现Intra(过程内)和Inter(过程间)分析，当遇到<code>call site</code> 就在环境中找到该方法名并进入其AST进行分析，从而实现<code>inter</code>能力。</p></li>
<li><p>实现污点分析。</p></li>
</ol>
<p>(说的挺复杂，开源版的RIPS的基础分析能力还是以分析tokens流并以各种数据结构辅助追踪为主)</p>
<h2 id="创新点">创新点</h2>
<p>那么本paper novel在什么地方呢：</p>
<ul>
<li>在污点分析时添加了sanitization tags来表明数据被过滤</li>
<li>为952个内建方法建模，从而更精准的把控整个分析流的变化</li>
<li>在处理include file时，当作functions来处理，而不是直接加入到当前CFG，防止重复分析, 减少开销</li>
<li>根据基本块边来总结他们之间的sanitization影响</li>
<li>实现了后向污点分析，每一个基本块的分析结果，cache到一个变量里。</li>
<li>使用上下文敏感字符分析(context-sensitive stirng analysis)来精炼污点分析结果，基于当前环境。</li>
</ul>
<h2 id="cfgbuilder">CFGBuilder</h2>
<p>要构建一个CFG, 先定义statements, 划分基本块。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125759.png" alt="image-20201102203138487" style="zoom:50%;" /></p>
<p>这里作者定义了几种划分基本块的stmt， 配合算法：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125801.png" alt="image-20201102203339071" style="zoom:50%;" /></p>
<p>中间的循环AST上的每一个点，如果遇到四种stmt的情况。</p>
<ul>
<li><p>JSTMT, 遇到IF, Switch, Try, Ternary, LogicalOr（后两个没见过）， 就递归分析每个分支下的基本块。将入口条件加到基本块头。</p></li>
<li><p>LSTMT, 生成循环基本块</p></li>
<li><p>SSTMT, 停止，基本块下的stmts不可达</p></li>
<li><p>RSTMT, return,到达return或者是探测到程序退出，就不和下一个基本块建立连接。</p>
<p>这里增量在<code>simluate()</code>方法上，来看。</p></li>
</ul>
<h2 id="simulating-basic-blocks">simulating Basic Blocks</h2>
<p>静态分析能干的事，就是编译器或者解释器能干的事。 RIPS为获取基本块内的data flow, 在控制流的基础上进行所谓的simulating，实现simulating:</p>
<ol type="1">
<li>制定symbols: 值-val, 变量名-varibale, 常量-constant, 数组-ArrayDimFetch... 每一个symbol都会有几个状态(type, encoding, sanitization)，通过观察状态变化做到对类型，编码以及sanitize的敏感。</li>
</ol>
<p>2）Block Summary: 此过程就是将制定的符号集在块中使用进行后向追踪。生成一些块属性(block Summary):</p>
<pre><code>  * DataFlow - 记录变量/数组的assign
  * Constants - 记录常量的assign
  * GlobalDefines - 记录名称，加入global scope
  * ReturnValue - 记录块中的返回值(每个块一个返回， return和exit后的代码丢弃)
  * registerGlobals - 记录使用extract()或者import_request_varibales()注册变量</code></pre>
<p>在每个块的后向data flow分析后记录以上内容， 生成block summary.</p>
<ol start="3" type="1">
<li><p>Data Flow Analysis</p></li>
<li><p>Simulating Includes and Dynamic Code： php 的includes是一个动态表达式，通过路径去找，找到加入，若无正则匹配。eval同理。</p></li>
<li><p>Simulating Built-in Functions:</p></li>
</ol>
<p>​ 本文重点。 对621个内建函数进行数据流建模， configured name and effected parameters. 分类如下：</p>
<ul>
<li>Alphanumeric(284): 返回值只有字母数字组成的，effectively sanitize. 如: md5(), strlen()</li>
<li>Argument(122): 原样返回实参或部分的, 如： trim(), strrev()</li>
<li>escape(20): mysql_real_escap_string()这种， 遇到将symbol中的sanitization属性打上SQLI_SQ 和 SQLI_DO标签(如果没遇到就SQLI_NQ)</li>
<li>Substring(6): substr(), chunk_split()这种，返回实参字串的。</li>
<li>Encode(18): urlencode(), base64_encode() ...</li>
<li>Decode(25): urldecode(), base64_decode()...</li>
<li>Callbacks(51): 回调函数，如果调用函数名事字符串，就调用分析。如果是变量，正则猜测。</li>
</ul>
<h2 id="intra-produral-analysis">Intra-produral Analysis</h2>
<p>实现intra</p>
<h2 id="inter-procedural-analysis">Inter-procedural Analysis</h2>
<p>实现inter</p>
<h2 id="simluating-block-edges">Simluating Block Edges</h2>
<p>块与块之间的simluating, 考虑validation的情况</p>
<ul>
<li>operators(6): isset(), empty()...</li>
<li>Type checks(21): is_numeric()...</li>
<li>File checks(11): is_file()...</li>
<li>Whitelists(3): array_search()</li>
<li>Regex(8): 正则</li>
</ul>
<p>（原来validatation的情况可以放到块与块间，这样就和sanitization的情况分开来去了）。</p>
<h2 id="taint-analysis">Taint Analysis</h2>
<p>污点分析探测漏洞的过程略。:&gt;</p>
<h2 id="后记">后记</h2>
<p>之前看这篇觉得没啥东西， 仔细分析来东西还是挺多的， 毕竟顶会。</p>
<p>他几乎把所有语言特性层和面向过程层的东西讲到了， 缺少OO层的分析，也是后来不上人针对发文的。</p>
<p>(为什么看起来这么高大上的东西开源版本用起来和...一样)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/01/NDSS-14-RIPS/" data-id="cl1q2wlhh000547w53uzb3w60" data-title="Simulation of Built-in PHP Feature for Precise Static Code Analysis" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper/" rel="tag">paper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RAID-2020_Relfected_Server_XSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/26/RAID-2020_Relfected_Server_XSS/" class="article-date">
  <time class="dt-published" datetime="2020-10-26T00:47:41.000Z" itemprop="datePublished">2020-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/26/RAID-2020_Relfected_Server_XSS/">What&#39;s in an Exploit? An Empirical Analysis of Reflected Server XSS Exploitation Techniques</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/iohehe/research/RAID-2020-xss-stats-paper/xss-stats-paper.pdf">原文链接</a></p>
<p>本文发表自RAID2020年，作者来自微软、东北大学和纽约大学。一项对反射型XSS的实证分析研究。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045716.png" alt="image-20201030143613662" style="zoom:33%;" /></p>
<p>本文从XSSED和OPENBUGBOUNTY两个网站收集了近十年来的反射型XSS提交的payload。 两个测试集OBB的比较新一些。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045726.png" alt="image-20201030162110612" /><figcaption aria-hidden="true">image-20201030162110612</figcaption>
</figure>
<p>在此即上进行EXP分析，设计了一个验证系统。证明这些反射型的EXP是可以被精确的识别出来的。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045729.png" alt="image-20201030162154660" /><figcaption aria-hidden="true">image-20201030162154660</figcaption>
</figure>
<p>整个系统分为动态和静态两个佐证部分，尝试识别出每个exp的trick:</p>
<ul>
<li><p>静态：</p>
<p>静态部分是:EXP Extraction ​到​ ​S​t​a​ti​c​ ​F​e​a​t​ur​e​ ​E​x​t​ra​c​t​i​on。​ 其实我觉得还带是正则。</p></li>
<li><p>动态：</p>
<p>动态部分是：EXP Execution 到 Dynamic Feature Extraction。 将收集的response的page使用chrome和FireFox加载，在沙箱环境中观察，因为有一些触发条件需要特定操作或者加载资源，因此作者分了四个round，后三个round需要操作(Mouse Move, Mouse Click, Network Error)，通过在response page中插桩，观察XSS执行里的trick。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045734.png" alt="image-20201030173010493" /><figcaption aria-hidden="true">image-20201030173010493</figcaption>
</figure></li>
</ul>
<p>下面来看看对payload的一些分统计：</p>
<ol type="1">
<li><p>Context( Escaping and Creation)技术:</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045732.png" alt="image-20201030163940277" /><figcaption aria-hidden="true">image-20201030163940277</figcaption>
</figure></li>
</ol>
<p>这一类主要是指逃逸+构造，日常使用中确实最多。细分为： HTML环境注释逃逸法、 JS环境注视逃逸法、属性环境标签闭合逃逸+构造标签、属性环境属性闭合+构造属性、JS环境代码续接。 （我瞎编的:expressionless:)​</p>
<ol start="2" type="1">
<li>Synatx Confusion技术</li>
</ol>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045740.png" alt="image-20201030164425916" /><figcaption aria-hidden="true">image-20201030164425916</figcaption>
</figure>
<p>这一类就是语法混淆，包括： 方法名的额外括号、大小写混淆、 unicode编码混淆(乱入：注意方法括号不能unicode)、第四个厉害了没听说过、 空白符混淆、 斜杠替换空格(还有alert(/xss/))、 标签解析混淆(频率还很高，mark!)</p>
<ol start="3" type="1">
<li>Control Flow Modification技术</li>
</ol>
<p>此技术在OBB的测试集中使用比较多。也就是有48.2%的</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045744.png" alt="image-20201030165941047" /><figcaption aria-hidden="true">image-20201030165941047</figcaption>
</figure>
<p>这个分类粒度是控制流更改(可能喝上两种不是一个维度)。主要是躲过&lt;script&gt;标签过，有1, 自动触发事件 2，exploit-triggered events(咋翻译？) 3,用户交互事件 4, 将事件赋给一个变量！ 5，抛异常！！</p>
<p>这个类型分的有点混乱，可能我还没看仔细。</p>
<ol start="4" type="1">
<li><p>字符解释技术</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045746.png" alt="image-20201030171318469" /><figcaption aria-hidden="true">image-20201030171318469</figcaption>
</figure>
<p>能够将字符当作JS代码解释的方法， 1，document.write 2, eval 3, setTimeout 4, top (写一遍加深印象...)</p></li>
</ol>
<h2 id="总结">总结</h2>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-045749.png" alt="image-20201030171651652" /><figcaption aria-hidden="true">image-20201030171651652</figcaption>
</figure>
<p>En...还是闭合标签感觉爽些。</p>
<h2 id="tips">Tips</h2>
<p>看完这篇文章其他部分没仔细看， 光学姿势去了...</p>
<ul>
<li>可能有些位置就是可以用多种方法，最近趋于喜欢直接用svg做注入</li>
<li>是时候总结一波姿势了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/26/RAID-2020_Relfected_Server_XSS/" data-id="cl1q2wlhk000a47w55st90dhz" data-title="What&#39;s in an Exploit? An Empirical Analysis of Reflected Server XSS Exploitation Techniques" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper/" rel="tag">paper</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-recuv" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/15/recuv/" class="article-date">
  <time class="dt-published" datetime="2020-09-15T03:13:08.000Z" itemprop="datePublished">2020-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/15/recuv/">递归</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>设计一个递归函数， 考虑三个方面： 参数、 中间量、返回值</p>
<ul>
<li><p>参数： 设计递归表达式中包含的关键东西， 每一次调用，只有参数在改变。</p></li>
<li><p>中间量：中间每次调用时，会在一个新的栈中存储，他在内存上和上次的变量是两块独立的空间，他们的行为只依赖于参数的变化。</p></li>
<li><p>返回值： 需要所有过程共同的return值来完成。</p></li>
</ul>
<p>每一次函数调用，都有一个独立的函数栈空间， 理解好这个就可以更好的理解递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new_str = [] // 返回值</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">_<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">global</span> new_str</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(_<span class="built_in">str</span>) &gt; <span class="number">1</span>): //中间量</span><br><span class="line">        x = _<span class="built_in">str</span>.pop() //中间量</span><br><span class="line">        new_str.append(x)</span><br><span class="line">        recv(_<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">return</span> new_str</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    _<span class="built_in">str</span> = [<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;0&quot;</span>] //参数</span><br><span class="line">    res = recv(_<span class="built_in">str</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>之前在遍历子路径时没想明白， 就在于我没有理解好每一次调用变量都存在独立的站。在递归返回上一级的时候，父函数在工作环境中继续施工，所以之前的内容都在。哈哈哈真的是，太菜了</p>
<p>(这里的new_str不写在递归区域， 因为new_str是返回值，所以不能每个过程都开一个新的，而是每次都将结果压入一个共同的空间中)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/15/recuv/" data-id="cl1q2wlhx001247w55o0j4urr" data-title="递归" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-taint" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/09/taint/" class="article-date">
  <time class="dt-published" datetime="2020-09-09T01:34:58.000Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/09/taint/">taint</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如下是一个典型污点分析算法：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044109.png" alt="截屏2020-09-09 上午9.38.59" style="zoom: 67%;" /></p>
<p>一般地，污点分析会选择后向追踪。如果前向按照程序执行的方向追踪，即从sources找sinks往往会有很多误报。 从sinks后向找的话首先定位了漏洞点了。后向的话就是在一个赋值过程中<code>左值为污点传播给右值(lval-&gt;rval)</code> 那么一个后向算法的实现：</p>
<ul>
<li>第一步： 根据设定的sinks列表， 在程序中全局定位所有的sinkNodes的位置</li>
<li>第二步： 对每一个sinkNode进行后向追随，看有没有能够达到我们设定为sources的静态路径， 有就存为vulnerablePaths</li>
</ul>
<p>关键在于对每一个sink点如何追溯， 这里先不考虑地22行的filter。找到&lt;sink, source&gt;路径，核心是一个递归过程。这个过程的原操作是在数据流上向后走到下一个传播点，并将其标注为污点(taint)。 那么这个过程何时停？ 根据第18行，即当追到一个taint就是我们的sources，当然输出一条vulnerablePath。 当追到了Parameters时，此时此过程中的污点传播已经到头，说明污点已经传入了他的caller中，将此路径保存，停止污点追溯，回到他的caller中，如果caller中构造了vulnerablePaths，在讲这种由return传播到parameter的过程路径拼接。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044114.jpg" alt="WechatIMG10" style="zoom:67%;" /></p>
<p>上图描述了从sink开始找到一个赋值语句，转移函数在这里要回答右值是否标为污点？但是他的表达式中有一个call，要回答这个问题就我们就要分析这个调用。</p>
<p>如果将这个call看作一个黑盒的话，首先它一定要有返回值，如果没有返回值， 那么就没有数据传到sink点了(这里考虑的是显式传播，不考虑控制流的影响)。其次，要看我们的taint点，是否做为实参传入，如果做为实参传入，且从return点能够从数据流后向走到Parameters(这个taint的传入位置)，那么就做为一个子过程，拼接到path上(path+call_path)。 还有就是自过程中包含source，那么这个source直接就通过return和sink拼接成vulpath了。</p>
<p>递归过程:</p>
<ol type="1">
<li>检查call中是否有返回</li>
<li>有返回值，标注污点传入的参数位置</li>
<li>将返回点做为sink，后向污点分析，如果遇到source,输出vul_path；走到标注的参数，返回路径；遇到call继续递归该过程。</li>
</ol>
<p>给出一个Example，有空可以探测试一下。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo_1</span>(<span class="params"><span class="variable">$foo_1_param</span></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$foo_1_res</span> = <span class="string">&quot;&lt;a&gt;&quot;</span>.<span class="variable">$foo_1_param</span>.<span class="string">&quot;&lt;/a&gt;&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$foo_1_res</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo_2</span>(<span class="params"><span class="variable">$foo_2_param</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$foo_2_res</span> = <span class="title function_ invoke__">foo_1</span>(<span class="variable">$foo_2_param</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$foo_2_res</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$pass_2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_1</span> = <span class="title function_ invoke__">foo_2</span>(<span class="variable">$pass_2</span>);</span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$pass_1</span>;</span><br><span class="line">    <span class="title function_ invoke__">evil</span>(<span class="variable">$target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"><span class="variable">$target</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$target</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">bar</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>evil($target)</code>: 污点标为target</li>
<li><code>$target = $pass_1</code>: 污点标为$pass_1</li>
<li><code>$pass_1 = foo_2($pass_2)</code>: 污点标为foo_2的第一个Argument，转入foo_2
<ul>
<li>foo_2标记第一个Parameter</li>
<li>foo_2有return，从return开始追踪</li>
<li><code>return $foo_2_res</code>: 标记$foo_2_res为污点</li>
<li><code>$foo_2_res = foo_1($foo_2_param)</code>: 标记foo_2_param为污点，转入foo_1
<ul>
<li>foo_1标记第一个Parameter</li>
<li>foo_1有return，从return开始追踪</li>
<li><code>return $foo_1_res</code>: 标记$foo_1_param为污点</li>
<li><code>$foo_1_res = "&lt;a&gt;".$foo_1_param."&lt;/a&gt;";</code>：标记$foo_1_param为污点</li>
<li><code>function foo_1($foo_1_param)</code>: 污点传入标记的Parameter, 返回call_path</li>
</ul></li>
<li><code>$foo_2_res = foo_1($foo_2_param);</code>: 拼接call_path,标记$foo_2_res为污点</li>
<li><code>function foo_2($foo_2_param)</code>: 污点传入标记的Parameter, 返回call_path</li>
</ul></li>
<li><code>$pass_1 = foo_2($pass_2)</code>: 标记$pass_1为污点</li>
<li><code>$pass_2 = $_GET['id'];</code>: 找到source点，输出vulPath</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/09/taint/" data-id="cl1q2wli3001o47w57p0k1r31" data-title="taint" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-byte" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/19/byte/" class="article-date">
  <time class="dt-published" datetime="2020-08-19T07:38:19.000Z" itemprop="datePublished">2020-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/19/byte/">byte</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>计算机和计算器的区别是什么？抛开体积、功能等等，我觉得最本质的区别还是处理的信息域。 计算器只有数学语言的有限编码，它更像是封装了计算机的一个处理数学符号的软件而已。</p>
<p>而为什么计算机可以处理几乎所有的信息域呢？计算机可以通过二进制的0和1，创造出更加丰富的编码来表示更多种类的信息。起初可能计算机和计算器没什么不同，只是在处理一些数学运算。但是人们想通过它来处理文字信息。 对于英文这种拼音文字，大小写52个，加上一些符号等等。首先我们要通过计算机表示这些符号，第一步就是要通过二进制去制定一个规则去表示(映射)他们。那么二进制中，1位可以携带两种信息，2位有2的二次方即4中组合来表示信息。那么8位是128个，装下日常看的英文信息应该够用了。为了保险，又扩展到8位刚好比较合适，能表示256种符号而且不会太大。ASCII码就是这么干的，当然可以其他的位数表示一个btye，但是现在通常来说，1btye=8bits。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/19/byte/" data-id="cl1q2wlho000i47w5514t3sni" data-title="byte" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rips" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/12/rips/" class="article-date">
  <time class="dt-published" datetime="2020-08-12T04:06:21.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/12/rips/">rips</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>抱着我一定要更新博客的决心， 我开始了RIPS折腾笔记。</p>
<h1 id="x00-背景">0x00 背景</h1>
<p>PHP静态分析有个里程碑式的工具-RIPS，这个工具是最早Dahse博士提出来的， 现在早已闭源。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125136.png" alt="截屏2020-08-12 下午12.11.26" style="zoom: 50%;" /></p>
<p>到0.55是开源的最后一个版本。</p>
<p>10年到17年期间，Dahse发表的文章有：</p>
<ul>
<li>2010 - RIPS-A static source code analyser for vulnerabilities in PHP scripts : 简单介绍RIPS工具，对应在0.3版本</li>
<li>2014 - Simulation of Built-in PHP Features for Precise Static Code Analysis: 发表在NDSS上， 如何模拟内建函数来精确静态分析</li>
<li>2014 - Static Detection of Second-Order Vulnerabilities in Web Applications: 发表在USENIX上，二次注入漏洞探测问题。</li>
<li>2014 - Code Reuse Attacks in PHP: Automated POP Chain Generatio: 发表在CCS上，POP链探测</li>
<li>2015 - Experience report: an empirical study of PHP security mechanism usage: 一个软工的B</li>
<li>2016 - Thesis. Static Detection of Complex Vulnerabilities in Modern PHP Applications: 总结性的文章，毕业了...</li>
</ul>
<p>不得不说， 时间点卡的非常好， 10-15年正是PHP发展火爆的上升期，在14年发表了三篇也是醉了。如今四大上关注PHP的文章寥寥。</p>
<hr />
<h1 id="x01-0.32版本工作流程">0x01 0.32版本工作流程</h1>
<p>能找的最早版本，是RIPS-0.32，从这一版开始，结合文章资料开始分析，看RIPS是如何发展起来的。(此时还没有相对复杂的前端)</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125142.png" alt="截屏2020-08-12 下午3.32.16" /><figcaption aria-hidden="true">截屏2020-08-12 下午3.32.16</figcaption>
</figure>
<p>目录相对也简单， 直接index.php入口，也没有正则搜索功能了(虽然我平时只用这个)。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125147.png" alt="截屏2020-08-12 下午3.38.13" /><figcaption aria-hidden="true">截屏2020-08-12 下午3.38.13</figcaption>
</figure>
<p>画风可以说非常的清气，板正。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125149.gif" alt="6a04b428gy1g0zyyluaozg203j036no9" /><figcaption aria-hidden="true">6a04b428gy1g0zyyluaozg203j036no9</figcaption>
</figure>
<p>看代码入口处：</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125152.png" alt="截屏2020-08-12 下午3.42.20" /><figcaption aria-hidden="true">截屏2020-08-12 下午3.42.20</figcaption>
</figure>
<p>导入config里是一些需要使用的数据；functions里是处理token，扫描和输出三个功能；classes是定义了几个需要使用的数据结构(以类的形式，其实更像是结构体)。</p>
<p>根据作者的污点分析论述，此版本RIPS有139个PVFs(潜在漏洞函数)，首先第一步找到这些漏洞函数，这些PVFs标记在<code>config/PVF.php</code>中，如一个命令执行：</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125153.png" alt="截屏2020-08-12 下午3.52.20" /><figcaption aria-hidden="true">截屏2020-08-12 下午3.52.20</figcaption>
</figure>
<p>我们扫描这样一段代码：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125157.png" alt="截屏2020-08-14 下午3.28.27" style="zoom:50%;" /></p>
<p>看到没，这是一个命令执行，最后输出：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125201.png" alt="截屏2020-08-14 下午3.29.18" style="zoom: 67%;" /></p>
<p>从效果上看，是一个完整有效的污点分析了噜， 大体来看这段代码的扫描是怎样实现的？ 大致分为三个阶段：读代码-&gt;token化-&gt;扫描。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125204.png" alt="截屏2020-08-14 上午10.47.59" /><figcaption aria-hidden="true">截屏2020-08-14 上午10.47.59</figcaption>
</figure>
<p>RIPS将所有文件读入到$data，然后循环针对每一个文件进行scan_file。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125209.png" alt="截屏2020-08-14 下午4.14.08" /><figcaption aria-hidden="true">截屏2020-08-14 下午4.14.08</figcaption>
</figure>
<blockquote>
<p>file_name文件名， scan_functions目标PVFs，其他T开头的都是从tokens中读取的标识好的token集合。</p>
</blockquote>
<p>进入<code>scan_file</code>方法也就是进入了<code>functions/scan.php</code>这个文件中，它是扫描的主逻辑所在地，文件在此完成扫描。先进行token化代码然后在此之上进行一些处理</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125213.png" alt="截屏2020-08-14 下午4.25.13" /><figcaption aria-hidden="true">截屏2020-08-14 下午4.25.13</figcaption>
</figure>
<p>这里的<code>$lines_pointer</code>是一个<code>scan_file</code>里注册的一个局部变量，用来装目标源码的。总之做了一些处理，放入到<code>$tokens</code>这个就是待分析源吗的目标token，进行<code>prepare_tokens</code>和<code>fix_tokens</code>，这里使用token进行污点分析的一个很关键的点就是我们分析每一个token的时候可以通过当前token的标号在<code>$tokens</code>这个数组中随意提取周围的token以确定代码环境。这样我们就需要把<code>$tokens</code>进行一些处理，比如去掉空格这种东西，因为<code>$a=$b</code>有的人会加任意空格<code>$a = $b</code>这样我们计算这个表达式的时候比如扫描到了<code>$a</code>我们需要知道这是不是一个<code>declare</code>就要在<code>$tokens[i+1]</code>找等号。这些工作是在token处理中完成的(<code>prepare_tokens</code>)，然后这里是在一个基本块里的例子，<code>fix_tokens</code>没什么用所以先不理会。</p>
<p>接下来就是扫描阶段：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$tokencount</span>=<span class="title function_ invoke__">count</span>(<span class="variable">$tokens</span>); <span class="variable">$i</span>&lt;<span class="variable">$tokencount</span>; <span class="variable">$i</span>++) <span class="comment">//遍历每一个token</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable">$token</span> = <span class="variable">$tokens</span>[<span class="variable">$i</span>]; <span class="comment">//此处既有当前token又保留了tokens可以随意提取周围token。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$token</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    ...token是数组处理</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    token不是数组处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处迭代每一个<code>$tokens</code>。分为数组和非数组两大块，每一块又分不同的情形：</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125219.png" alt="截屏2020-08-14 下午4.51.44" /><figcaption aria-hidden="true">截屏2020-08-14 下午4.51.44</figcaption>
</figure>
<p>这里简单记录了一下他的注释。针对每种情况的不同 RIPS有自己处理的case。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125223.png" alt="截屏2020-08-14 下午5.09.07" /><figcaption aria-hidden="true">截屏2020-08-14 下午5.09.07</figcaption>
</figure>
<p>看对上边的代码进行扫描，起作用的token，看到这个最简单的污点追踪，分别有<code>variable declarations</code>和标红的<code>check if token is a function call and a function to scan</code></p>
<h2 id="变量声明信息">变量声明信息</h2>
<p>在扫描到第0个token的时候，进入这个判断:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="variable">$token_name</span> === T_VARIABLE</span><br><span class="line">					&amp;&amp; ( <span class="variable">$tokens</span>[<span class="variable">$i</span>+<span class="number">1</span>][<span class="number">0</span>] === <span class="string">&#x27;=&#x27;</span> || <span class="comment">// normal assignment</span></span><br><span class="line">					  (<span class="title function_ invoke__">in_array</span>(<span class="variable">$tokens</span>[<span class="variable">$i</span>+<span class="number">1</span>][<span class="number">0</span>], <span class="variable">$T_ASSIGNMENT</span>))  <span class="comment">// mathematical assignment</span></span><br><span class="line">					  || (<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>][<span class="number">0</span>] === T_AS <span class="comment">// foreach($var as $key=&gt;$value)</span></span><br><span class="line">					   || (<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>][<span class="number">0</span>] === T_DOUBLE_ARROW</span><br><span class="line">					    &amp;&amp; <span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">2</span>][<span class="number">0</span>] === T_VARIABLE)) </span><br><span class="line">					   || (<span class="variable">$tokens</span>[<span class="variable">$i</span>+<span class="number">1</span>] === <span class="string">&#x27;[&#x27;</span>  <span class="comment">// $foo[&#x27;a&#x27;], hard to check all keys and assignments</span></span><br><span class="line">					   <span class="comment">// example: $a[0][$i+$k] &amp;= $_GET[&#x27;a&#x27;];</span></span><br><span class="line">					   <span class="comment">// easier: the last token was an ending statement or beginning of the file</span></span><br><span class="line">					   &amp;&amp; (<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>] === <span class="string">&#x27;&#125;&#x27;</span> || <span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>] === <span class="string">&#x27;&#123;&#x27;</span> </span><br><span class="line">						|| <span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>] === <span class="string">&#x27;;&#x27;</span> || !<span class="keyword">isset</span>(<span class="variable">$tokens</span>[<span class="variable">$i</span>-<span class="number">1</span>][<span class="number">0</span>]))) </span><br><span class="line">					  ) </span><br></pre></td></tr></table></figure>
<p>这个条件很长， 为了涵盖所有变量声明的形式，此处是最简单的<code>normal assignment</code>也就是在<code>$tokens[$i+1][0]</code>处发现了<code>=</code>，即0号token是一个变量而1号token是一个'='也就是说这个变量是一个左值，他正在被注册，因此进入该逻辑，new 一个<code>varDeclare</code>来注册这个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	</span><br><span class="line">// variable declarations = childs</span><br><span class="line">	class VarDeclare</span><br><span class="line">	&#123;</span><br><span class="line">		public $id;</span><br><span class="line">    	public $value;</span><br><span class="line">    	public $line;	</span><br><span class="line">		public $marker;</span><br><span class="line">		public $dependencies;</span><br><span class="line">		</span><br><span class="line">		function __construct($value = null) </span><br><span class="line">		&#123;</span><br><span class="line">			$this-&gt;id = 0;</span><br><span class="line">			$this-&gt;value = $value;</span><br><span class="line">			$this-&gt;line = &#x27;&#x27;;</span><br><span class="line">			$this-&gt;marker = 0;</span><br><span class="line">			$this-&gt;dependencies = array();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先进入这个逻辑：</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125229.png" alt="截屏2020-08-14 下午5.27.13" /><figcaption aria-hidden="true">截屏2020-08-14 下午5.27.13</figcaption>
</figure>
<p>先经过getmultiline的处理（提取整句语句），然后注册一个对象，填数据。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125235.png" alt="截屏2020-08-14 下午5.29.19" /><figcaption aria-hidden="true">截屏2020-08-14 下午5.29.19</figcaption>
</figure>
<p>然后把它插入到<code>$var_declares_global</code>中供之后分析使用(如果是函数内部的变量注册到<code>$var_declares_local</code>数组中)。同理，第7个token亦是如此。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125237.png" alt="截屏2020-08-14 下午5.32.23" /><figcaption aria-hidden="true">截屏2020-08-14 下午5.32.23</figcaption>
</figure>
<p>这样我们便能拿到所有的变量声明信息。</p>
<h2 id="pvf分析">PVF分析</h2>
<p>当到走到第四行的<code>system</code>token后判断他是一个PVF。这是后就注册一个<code>VlnTreeNode</code>然后进行污点分析， 因为认为这个污点函数的参数是之前的变量传播的，与后边的token无关，因此触发一次污点分析。</p>
<p>找到PVF system的token后， rips就开始生成一个<code>VulnTreeNode</code>对象，叫做<code>$new_find</code>，来记录这个污点链。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125240.png" alt="截屏2020-08-12 下午4.34.39" /><figcaption aria-hidden="true">截屏2020-08-12 下午4.34.39</figcaption>
</figure>
<p>初始化了name，和lines(第4行的system)。接下来进行污点追踪，我们来看scan_parameter这个函数的标头：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scan_parameter</span>(<span class="params"><span class="variable">$file_name</span>, <span class="variable">$mainparent</span>, <span class="variable">$parent</span>, <span class="variable">$var_name</span>, <span class="variable">$var_declares</span>, <span class="variable">$last_token_id</span>, <span class="variable">$var_declares_global</span>, <span class="variable">$function_params</span>, <span class="variable">$function_obj</span>, <span class="variable">$userinput</span>, <span class="variable">$F_SECURES</span>, <span class="variable">$return_scan</span>=<span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>开始进入的时候<code>$mainparent</code>和<code>$parent</code> 都是由<code>$new_find</code>传来的:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$userinput</span> = <span class="title function_ invoke__">scan_parameter</span>(<span class="variable">$file_name</span>, <span class="variable">$new_find</span>, <span class="variable">$new_find</span>, <span class="variable">$trace_par_var</span>, <span class="variable">$var_declares_global</span>, <span class="variable">$i</span>+<span class="variable">$c</span>, <span class="literal">null</span>, <span class="keyword">array</span>(), <span class="literal">null</span>, <span class="literal">false</span>, <span class="variable">$scan_functions</span>[<span class="variable">$token_value</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125243.png" alt="截屏2020-08-14 下午9.20.34" /><figcaption aria-hidden="true">截屏2020-08-14 下午9.20.34</figcaption>
</figure>
<p>这么进来了，<code>$trace_par_var</code>是第一个参数也就是<code>$b</code>，追踪这一个变量，直到找到相关的declare，然后递归...</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125246.png" alt="截屏2020-08-14 下午9.22.15" /><figcaption aria-hidden="true">截屏2020-08-14 下午9.22.15</figcaption>
</figure>
<p>此时栈中有两个<code>scan_parameter</code>了， 第一个是<code>$b</code>，第二个是<code>$a</code>，此时<code>$mainparent</code>不变，而<code>$parent</code>更新， <code>$var_name</code>也是这一次递归的目标变量<code>$a</code>，继续...</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125250.png" alt="截屏2020-08-14 下午9.26.29" /><figcaption aria-hidden="true">截屏2020-08-14 下午9.26.29</figcaption>
</figure>
<p>看一下三次递归：</p>
<ul>
<li><p>$last_token_id: 13-&gt;7-&gt;0</p></li>
<li><p>$var_name: <span class="math inline">\(b-&gt;\)</span>a-&gt;$_GET['a']</p></li>
</ul>
<p>其中还有一些变量的变化还没有仔细去追。总之走到userinput之后，<code>scan_parameter</code>出栈的时候会通过<code>output.php</code>进行记录，然后整个结果展示粗来。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125255.png" alt="截屏2020-08-12 下午4.41.00" /><figcaption aria-hidden="true">截屏2020-08-12 下午4.41.00</figcaption>
</figure>
<p>okay~ 大致是这样。</p>
<h1 id="x02-总结">0x02 总结</h1>
<p>目前已经基本走通了一个基本块内的污点分析，做为一个完整的污点分析，你甭管在什么层面，用什么方法，只要能达到效果就成， 这里在token层面进行分析，判断条件写的也很复杂，主要就是想要通过对token环境的约束覆盖所有的情况来。那么接下来还要考虑控制语句(包括三元运算符)，过程间分析，OOP特性，语言动态特性...，总之，祝你幸福。</p>
<p>P.S. 本来想写完全分析的，有点长，有空再来篇新的。</p>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-30-125300.jpg" alt="Unknown" /><figcaption aria-hidden="true">Unknown</figcaption>
</figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/12/rips/" data-id="cl1q2wlhx001447w57kwu2xji" data-title="rips" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-static-analysis-6-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/27/static-analysis-6-md/" class="article-date">
  <time class="dt-published" datetime="2020-07-27T01:10:33.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/27/static-analysis-6-md/">南大静态分析6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol start="7" type="1">
<li><p>Relate Iterative Algorithm to Fixed Point Theorem 4:20</p></li>
<li><p>May/Must Analysis, A Lattice View 26:10</p></li>
<li><p>MOP and Distributivity 64:30</p></li>
<li><p>Constant Propagation 80:40</p></li>
<li><p>Worklist Algorithm 102:00</p>
<p>总结&amp;欢迎谭添老师</p></li>
</ol>
<h1 id="南大静态分析6">南大静态分析6</h1>
<p>上回说到为了解决iterative algorithm中的三个问题， 我们引入了数学模型来进行形式化证明。 那么如何让在lattic上呈现的fixed point theorem与iterative algorithm关联起来呢？接下啦我们来看。</p>
<p>首先回顾一下iterative algorithm的三个问题：</p>
<h2 id="review-the-questions-we-have-seen-before">Review The Questions We Have Seen Before</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042842.png" alt="截屏2020-05-30 上午8.34.28 " style="zoom:60%;" /></p>
<p>我们现在尝试回答三个问题。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042846.png" alt="截屏2020-07-29 上午8.56.22 " style="zoom:20%;" /></p>
<blockquote>
<ol type="1">
<li>算法一定能达到不动点吗？(lattice 上单调性问题)</li>
<li>如果有不动点，只能有一个动点吗</li>
<li>不定点是解吗</li>
</ol>
</blockquote>
<h2 id="relate-iterative-algorithm-to-fixed-point-theorem">Relate Iterative Algorithm to Fixed-Point Theorem</h2>
<blockquote>
<p>04:20</p>
</blockquote>
<p>将<code>Iterative Algorithm</code>这个算法与<code>fixed point</code>进行关联(一种很intuition的证明)：</p>
<ul>
<li>Iterative Algorithm</li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-42857.png" alt="image-20210724073400818" style="zoom:8å0%;" /></p>
<ul>
<li>Fixed point:</li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042849.png" alt="image-20210724073420227" style="zoom:33%;" /></p>
<p>将二者的已知条件进行关联， 首先iterative algorithm 也需定义一个Lattice:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042854.png" alt="image-20210724092616707" style="zoom:60%;" /></p>
<p>在算法的k-tuple中， 每一个节点对应一个Lattice, 那么所有节点形成的vector就是一个Lattice的product。 那么整个iterative algorithm作用的是一个product lattice。</p>
<ul>
<li><p>在product lattice (L, L, L...L)中， 如果每一个L都是finite的complete lattice（complete lattice不一定finite哦），那么他们构成的product lattice也是finite的complete lattice。</p>
<p>通过此条我们就可以关联上不动点定理的第二个条件： <code>L is finite</code></p></li>
</ul>
<p>现在我们来关联不动点定理的第一条件：<code>f: L-&gt;L is monotonic</code>, 如何说明，iterative algorithm也是单调的呢？</p>
<p>首先，iterative algorithm的function是什么呢？</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042856.png" alt="image-20210724093452801" style="zoom:70%;" /></p>
<p>如上所言，在每一次迭代中，都会应用一个<code>function F</code>, 他由两部分构成：</p>
<ul>
<li><p>transfer function: 指定的transfer function, 根据IN[B],来进行kill和gen</p></li>
<li><p>join/meet function: 在控制流上，进入下一个program point之前的并/交操作</p>
<blockquote>
<p>e.g., F(iter1) = (v1....vk)</p>
</blockquote></li>
</ul>
<p>有了F, 接下来证明他是monotonic的：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042901.png" alt="image-20210724094200039" style="zoom:50%;" /></p>
<p>首先第一条之前也说过，每一个transfer function在固定的program point上，由程序性质所决定kill和gen都是一样的， 所以他是单调的(OUT只会增加，不会减少)。</p>
<p>再来证明第二条：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042902.png" alt="image-20210724094430990" style="zoom:50%;" /></p>
<p>这里的LXL是两条控制流path在进入program point之前进行merg, 也可以有多个(Actually the binary operator is a basic case), 我们只需要证明这个<code>basic case</code>是单调的就可以了。</p>
<p>我们来证join是单调的：</p>
<p>根绝我们之前对单调函数的定义:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042905.png" alt="image-20210723224024442" style="zoom:50%;" /></p>
<p>此时的function是一个join(U)操作， 因此，我们的function是证明:<img src="static-analysis-6-md/image-20210724095135553.png" alt="image-20210724095135553" style="zoom:50%;" />。</p>
<p>join在lattice求的是任意两个元素的最小上界(least upper bond)，那么<code>yUz</code>是y的upper bound，同时也是z的upper bond。根据upper bound 的定义得到:<img src="static-analysis-6-md/image-20210724095550037.png" alt="image-20210724095550037" style="zoom:50%;" />, 根据偏序关系中的传递性，我们就可以得出: <img src="static-analysis-6-md/image-20210724095708642.png" alt="image-20210724095708642" style="zoom:50%;" />, 然后得到完整的证明:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042908.png" alt="image-20210724095809112" style="zoom:67%;" /></p>
<p>因为根据join(U)的定义, yUz是y和z的一个upper bound，那么y &lt;= yUz。 之后通过偏序关系(&lt;=)的传递性得到: x&lt;=yUz。因此，yUz就是x,y,z的一个upper bound。</p>
<p>根据join的定义xUz是least upper bound of x and z。 那么根据最小上界(least upper bound)的定义： xUz &lt;= yUz。(最小上界“小于等于”任何一个上界)。</p>
<p>因此，现在将fixed point theorem的两个条件都和iterative algorithm有所关联了，那么就可以使用fixed point theorem 来说明之前提到的iterative algorithm for data flow analysis 上的问题。</p>
<p>给出两个结论，我们的iterative algorithm根据不动点定理：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042910.png" alt="image-20210724100647990" style="zoom:70%;" /></p>
<ol type="1">
<li>算法保证一定能够达到fixed point</li>
<li>达到的fixed point 要么是greatest fixed point, 要么是least fixed point</li>
<li>探讨algorithm的一个复杂度的问题，如果前边两条成立，那么什么时候算法才能达到不动点呢？</li>
</ol>
<p>为了说明第三点，首先引入<code>height of a lattice</code>的定义：</p>
<blockquote>
<p>The <code>height of a lattice h</code> is the length of the longest path from Top to Bottom in the lattice.</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042914.png" alt="image-20210724101157035" style="zoom:50%;" /></p>
<p>Lattice的高度就是从top到bottom找最长的路径，上图中是h=3。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042917.png" alt="image-20210724103312667" style="zoom:70%;" /></p>
<p>第三个问题，就是说 The maximum iterations i, 最多的迭代次数，使得算法达到不动点(最坏的情况)。</p>
<p>做一个假设， 每次iteration, 在lattice上的每一步都做一个最微小的变化： lattice只移动移一步(相当于每次只有一个node变化， 且每个node中只有一个0变成1)。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044847.png" alt="image-20210724103609474" style="zoom:80%;" /></p>
<p>每次都只变化一个节点，将一个0变为1，那么最坏的情况就是遍历所有节点，将所有位由0变成1：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042920.png" alt="image-20210724104202980" style="zoom:80%;" /></p>
<p>最多就有h*k次iterations。</p>
<p>因此回答第三个问题：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042923.png" alt="image-20210724104308251" style="zoom:67%;" /></p>
<h2 id="may-and-must-analysis-a-lattice-view">May and Must Analysis, a Lattice View</h2>
<blockquote>
<p>26:10</p>
</blockquote>
<h2 id="映射">映射</h2>
<p>将一个power set做一个直观的映射</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042927.png" alt="image-20210724110530341" style="zoom:30%;" /></p>
<p>这里假设this lattice is a reuslt of the product lattice, 因为每一点都有一组k-tuple, 每一个点他都是一个lattice元素，我们要更新的是所有值，所以他是一个product lattice。</p>
<h3 id="may">May</h3>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042931.png" alt="截屏2020-08-13 上午8.50.36 " style="zoom:50%;" /></p>
<p>May analysis, 一般情况下是从bottom往top走， 一个lattice的bottom从may的角度来讲，就是一个<code>unsafe result</code>。 也就是说，</p>
<blockquote>
<p>无论是 may analysis 还是 must analysis都是从unsafe的result向safe的result来讲的。</p>
</blockquote>
<ul>
<li><p>Unsafe result : 为什么May analysis的unsafe 是在bottom呢？ 以 reaching definition为例， no definitions can reach 意味着对于每一个variable, 都没有任何一个defintion能够reach到。</p></li>
<li><p>Safe but useless result: 以reaching definition为例，表示对于每一个variable, 所有的definitions都有可能reach。他是safe的，但是没有用。</p></li>
</ul>
<p>我们想知道，我们的分析停在unsafe result 和safe but useless result 中间的某个值， 我们需要引入另外一个值： Truth。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042934.png" alt="image-20210724114149446" style="zoom:30%;" /></p>
<p>Truth, 程序动态执行时无论在什么样的书如下所有可能取得值的一个动态值的集合。</p>
<p>假设Lattice 上{a,c}是一个Truth的集合。 那么就可以画一条边界，如果是May的分析，就把a和c都包含。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042937.png" alt="image-20210724114733084" style="zoom:33%;" /></p>
<p>如何知道我们的分析会进入safe呢？</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042939.png" alt="image-20210724114839906" style="zoom:33%;" /></p>
<p>静态分析有两个要素：</p>
<ol type="1">
<li>data abstraction</li>
<li>safe approximation</li>
</ol>
<p>我们在设计一个静态分析时，将merg与transfer functie 设置成safe的，也就是说，我们的设计保证了我们的分析结果一定会超过Truth这一点。</p>
<p>进入safe之后何时停呢？</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042942.png" alt="image-20210724115204556" style="zoom:33%;" /></p>
<p>我们的不动点可以有很多，但是虽然有很多不动点， 但是我们使用iterative alogrithm求解出的不动点，由我们之前给出的证明，iterative alogrithm求解出的不动点，一定是最小不动点(least fixed point)。</p>
<p>那么我们得到的结果精度如何呢?</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042944.png" alt="image-20210724115547408" style="zoom:30%;" /></p>
<p>无论是may还是must分析， 都是从准到不准走。 如上图，越往上的不动点越不准的，因为我们使用iterative algorithm能达到的是leaset fixed point, 那就是你能达到的所有结果中，最准的。这就是为什么一旦达到不动点，但是我们达到的fixed points里最准的(但他不一定是truth)。</p>
<h3 id="must">MUST</h3>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042948.png" alt="截屏2020-08-13 上午8.54.34 " style="zoom:50%;" /></p>
<p>Must和May相反，一般是从Top(unsafe result)往下走到Bottom(Safe but unless result)。</p>
<p>以available expressions为例，他是一个must analysis:</p>
<ul>
<li>Top(unsafe result): 所有的expressions在某一点都available，结果unsafe。</li>
<li>Bottom(safe but unless result): No expressions are available, 么有expressions可以被重复利用， 所以是safe的，但是 没有用。</li>
</ul>
<p>在must analysis中， unsafe就是有误报的情况。 Must Analysis是top-down, 他根据iterative algorithm 走到的fixed point一定是greatest fixed point(就是最准的)。也就是说针对must analysis而言我们往下走到的greatest fixed point一定是最准的。</p>
<blockquote>
<p>Safe approximate 中safe是先满足的条件，能达到fixed point是后满足的。</p>
</blockquote>
<p>合照：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042951.png" alt="image-20210724122023792" style="zoom:70%;" /></p>
<h2 id="how-precise-is-our-solution">How Precise Is Our Solution?</h2>
<blockquote>
<p>64:30</p>
</blockquote>
<p>谈到精度的衡量， 我们就需要一个方法：</p>
<p>MOP: Meet-Over-All-Paths Solution(MOP)</p>
<p>其中，meet也包括了join, 就是所有分支汇聚到一点的情况。 具体就是：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042954.png" alt="image-20210724151555790" style="zoom:30%;" /></p>
<p>在control flow graph 中 path就是从entry开始一堆statement构成的Path； 有Path就有Transfer function <code>Fp</code>:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042956.png" alt="image-20210724151716351" style="zoom:50%;" /></p>
<p>就是这条流上每一点的transfer function 的composition。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-042959.png" alt="image-20210724151920020" style="zoom:20%;" /></p>
<p>MOP(Meet-Over-All-Paths Solution)就是枚举从Entry点到Si的所有path, 然后对每条Path应用<code>Fp</code>， 并将得到的结果join/meet起来：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043000.png" alt="image-20210724152233463" style="zoom:33%;" /></p>
<ul>
<li>not fully precise: 观察一下，所有的paths, may be not executable（动态运行时，无论什么输入之下都不能走的路径），在MOP中merge了此类路径，就是误报，所以就not fully precise。</li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043003.png" alt="image-20210724152410470" style="zoom:40%;" /></p>
<ul>
<li><p>Unbounded, and not enumerable: unbound就是说如果有循环的话，静态不可知循环终止(无边界)； not enumerable: 大型程序中，路径可能不可枚举的。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043006.png" alt="image-20210724152837254" style="zoom:40%;" /></p></li>
</ul>
<p>所以我们静态得到MOP其实是impractical的。</p>
<h3 id="iterative-algorithm-vs.-mop">Iterative Algorithm vs. MOP</h3>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043008.png" alt="image-20210724153327700" style="zoom:50%;" /></p>
<p>如图， 我们要求S4点的IN:</p>
<p>使用<code>iteractive algorithm</code>, 在所有merge的时候，用join: <img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043010.png" alt="image-20210724153422673" style="zoom:20%;" /></p>
<p>而使用<code>MOP(meet-over-all-paths)</code>的方法，是在每条path都算法之后，对每条path进行join: <img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043014.png" alt="image-20210724153642260" style="zoom:20%;" /></p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043016.png" alt="image-20210724153730294" style="zoom:30%;" /></p>
<p>上图我们可以看到，红色部分和黄色部分iterative algorithm 和 MOP其实是一样的，我们进行抽象：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043020.png" alt="image-20210724153845650" style="zoom:33%;" /></p>
<p>iterative algorithm和MOP有什么关系呢?</p>
<p>证明:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043023.png" alt="image-20210724154810672" style="zoom:30%;" /></p>
<ul>
<li>根据最小上界(least upper bound)定义, 我们有： x join y即是x的上界又是y的上界 (x&lt;=x u y and y &lt;= x u y)。</li>
<li>因为一个transfer function是单调的，我们有：</li>
<li><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043024.png" alt="image-20210724155201184" style="zoom:33%;" /></li>
</ul>
<p>根据偏序关系， 这就意味着F(x u y) 是F(x)和F(y)的upper bound。</p>
<ul>
<li><p>因为F(x)uF(y)是F(x)和F(y)的least upper bound, 所以我们有:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043028.png" alt="image-20210724155421510" style="zoom:33%;" /></p></li>
<li><p>左边就是MOP右边就是Ours =&gt; MOP &lt;= Ours</p></li>
</ul>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043029.png" alt="image-20210724155530412" style="zoom:33%;" /></p>
<p>因此， MOP更准。</p>
<p>上边证明出的MOP和Iteractive Algorithm(Ours)满足一个偏序关系， 那么偏序关系有一个自反性， 如果满足自反性，那么Iteractive Algorithm就可以和MOP的精度相同。</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043035.png" alt="image-20210724155905712" style="zoom:25%;" /></p>
<p>当Function是一个distributive(可分配性)的，就可以和MOP一样准：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043031.png" alt="image-20210724160020053" style="zoom:30%;" /></p>
<p>之前的4个分析，都是distributive的； 这样一类操作都可以叫做Bit-vector problems(or Gen/Kill problems)</p>
<blockquote>
<p>这里一类问题的集合操作都可以用集合的union和intersection操作</p>
</blockquote>
<p>Bit-vector problems都是distributive的。</p>
<p>那么有没有不是distributive的呢?(MOP更准)， 这里介绍了: <code>Constant Propagation</code>常量传播问题。</p>
<h2 id="constant-propagation">Constant Propagation</h2>
<p>Define:</p>
<p>Given a variable x at program point p, determine whether x is <code>guaranteed</code> to hold a constant value at p.</p>
<p>一个variable在某一点，是否保证x一定指向某一个常量。</p>
<ul>
<li>The OUT of each node in CFG, includes a set of pairs(x, v) where x is a variable and v is the value held by x after that node.</li>
</ul>
<p>这里的data flow的每个点上是一个个的pairs, 他代表了variable与value的对应。</p>
<p>设计一个Constant Propagation的data flow analysis framework我们接下来考虑他的方向，格和transfer function:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043038.png" alt="image-20210724161506207" style="zoom:33%;" /></p>
<ul>
<li><p>Data flow direction: 数据流的分析方向是前向的。</p></li>
<li><p>Lattice:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043041.png" alt="image-20210724165738837" style="zoom:33%;" /></p></li>
</ul>
<p>Lattice 来考虑两个构成部分: Domain of the values; Meet Operator。</p>
<p>首先看Domain:</p>
<ul>
<li>Bottom: NAC- 所有的variables都不是constants(safe but useless)</li>
<li>Top: UNDEF-因为我们的元素是一个个的pair, 初始时variable指向undefine</li>
</ul>
<p>再来看Meet:</p>
<ul>
<li><p>NAC n V = NAC， 不管V是啥，因为时safe的，汇聚点一定是NAC</p></li>
<li><p>UNDEF n V = V， 这里说明一下，一般一个data flow analysis只负责一件事情，这里虽然有uninitialized variables的问题（汇聚后undef的值变成v了）。但是在以constant propagation为目的分析中，不影响。</p></li>
<li><p>c n v 分两种情况，如果常量相同就是c, 不同就是NAC</p></li>
</ul>
<p>总结：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043044.png" alt="image-20210724171008706" style="zoom:33%;" /></p>
<p>再来看Transfer Function:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043046.png" alt="image-20210724171459396" style="zoom:33%;" /></p>
<p>Transfer Function中，比较特殊的是{(x, _)}, 因为元素是一个pair, 所以这里_是一个通配符，表示x无论指向什么，都会减去。</p>
<p>我们用val(x), 来知道val指向的值：</p>
<ul>
<li>s: x = c; gen{(x, c)}, x就指向c</li>
<li>s: x= y;(非constant), val(y)</li>
<li>s: x = y op z, 二元操作： 如果y, z 有一个是NAC，就是NAC， 有一个是UNDEF, 就是UNDEF, 如果两个都是常量val(y) op val(z)</li>
</ul>
<p>注意transform function只影响assignment statement。</p>
<p>下边说明contant propagation 不是distributivity:</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043049.png" alt="image-20210724172107062" style="zoom:33%;" /></p>
<p>可以看到，F（XnY）时C是NAC， F(X)nF(Y)时C是10。</p>
<blockquote>
<p>从Lattice上看，此例中NAC在10下边，所以在这个must analysis中越往下越不准的，所以MOP更准一些。</p>
</blockquote>
<h2 id="worklist-algorithm">Worklist Algorithm</h2>
<p>worklist algorithm是iterative algorithm的一种优化。</p>
<blockquote>
<p>在实际工作中，不会用iterative algorithm, 而worklist algorithm更实用一些。</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043052.png" alt="image-20210724172347184 " style="zoom:33%;" /></p>
<p>这里的终止条件要求，只要有一个basic block变化，就要让所有的basic block 都跑一遍，会有很多冗余。 而worklist的核心，就是只对那些可能变化的BB执行transfer function：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-043056.png" alt="image-20210724172559644" style="zoom:33%;" /></p>
<p>黄色的是新增的， 我们每一次迭代用新的out和之前的out比较， 如果一个out变了，那么意味着所有后继(successors)的IN变了。 我们就讲所有后继的B加入Worklist，就可以避免了大量的冗余计算。✌️～</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/27/static-analysis-6-md/" data-id="cl1q2wli1001f47w55qrhavcc" data-title="南大静态分析6" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PHP-AST" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/01/PHP-AST/" class="article-date">
  <time class="dt-published" datetime="2020-05-31T16:00:00.000Z" itemprop="datePublished">2020-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>放在这，没事儿了我就总结几个</p>
<h1 id="child-nodes">1 child nodes</h1>
<h2 id="ast_var">AST_VAR</h2>
<figure>
<img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044304.png" alt="截屏2020-07-14 下午4.07.05" /><figcaption aria-hidden="true">截屏2020-07-14 下午4.07.05</figcaption>
</figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span></span><br></pre></td></tr></table></figure>
<h2 id="ast_echo">AST_ECHO</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044306.png" alt="截屏2020-07-27 下午3.42.44" style="zoom:50%;" /></p>
<h1 id="child-nodes-1">2 child nodes</h1>
<h2 id="ast_call">AST_CALL</h2>
<blockquote>
<p>函数调用点</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044310.png" alt="截屏2020-06-01 下午5.41.28" style="zoom:50%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">foo</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: ARG_LIST - 参数列表</li>
<li>child1: 调用函数名</li>
</ul>
<h2 id="ast_dim">AST_DIM</h2>
<blockquote>
<p>数组引用</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123109.png" alt="截屏2020-06-01 下午5.48.46" style="zoom:50%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = foo[<span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: 数组名</li>
<li>child1: 索引值</li>
</ul>
<h2 id="zend_ast_prop">ZEND_AST_PROP</h2>
<blockquote>
<p>属性调用</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123113.png" alt="截屏2020-06-20 下午4.39.26" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$obj</span>-&gt;val;</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: objetct_name</li>
<li>child1: attr</li>
</ul>
<h2 id="zend_ast_while">ZEND_AST_WHILE</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123116.png" alt="截屏2020-06-20 下午4.42.05" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="variable">$a</span>==<span class="number">1</span>)&#123;</span><br><span class="line">  [stmt_list]...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: condtion</li>
<li>child1: stmt_list</li>
</ul>
<h2 id="ast_if_elemet">AST_IF_ELEMET</h2>
<blockquote>
<p>区别于AST_IF</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-083801.png" alt="截屏2020-07-14 下午4.37.36" style="zoom:67%;" /></p>
<p>AST_IF这个list下连接的每一个分支都由一个IF_ELEMENT进入。</p>
<ul>
<li>Child0 :条件判定式</li>
<li>Child1: 代码语句块</li>
</ul>
<h2 id="ast_binary_op">AST_BINARY_OP</h2>
<blockquote>
<p>二元操作</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-085207.png" alt="截屏2020-07-14 下午4.51.41" style="zoom:67%;" /></p>
<p>控制流、数据流走判定表达式的话都是直接连这个点。代表整个二元操作表达式。</p>
<p>在PHP-AST这个项目中， 此点有flags字段，决定作用方法：</p>
<p>https://github.com/nikic/php-ast/blob/1b5d767dd326f535288786130b2215744feb2cbf/tests/metadata.phpt#L97</p>
<ul>
<li><p>位逻辑运算 BINARY_BITWISE_OR, BINARY_BITWISE_AND, BINARY_BITWISE_XOR,</p></li>
<li><p>布尔逻辑运算 BINARY_BOOL_AND, BINARY_BOOL_OR, BINARY_BOOL_XOR,</p></li>
<li><p>算术运算 BINARY_ADD, BINARY_SUB, BINARY_MUL, BINARY_DIV, BINARY_MOD, BINARY_POW,</p></li>
<li><p>位运算 BINARY_SHIFT_LEFT, BINARY_SHIFT_RIGHT,</p></li>
<li><p>相等关系运算 BINARY_IS_EQUAL, BINARY_IS_NOT_EQUAL,</p></li>
<li><p>小于关系运算 BINARY_IS_SMALLER, BINARY_IS_SMALLER_OR_EQUAL,</p></li>
<li><p>等于运算 BINARY_IS_GREATER, BINARY_IS_GREATER_OR_EQUAL,</p></li>
<li><p>连接操作 BINARY_CONCAT,</p></li>
<li><p>其他(就是还不懂) BINARY_COALESCE,BINARY_IS_IDENTICAL, BINARY_IS_NOT_IDENTICAL, BINARY_SPACESHIP</p></li>
</ul>
<h2 id="ast_assign">AST_ASSIGN</h2>
<p>另一个非常常见的两孩子点，就是赋值语句。当然， 左值和右值。</p>
<p>数据流最爱连接的节点：</p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-090810.png" alt="截屏2020-07-14 下午5.07.42" style="zoom:67%;" /></p>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-090953.png" alt="截屏2020-07-14 下午5.09.18" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">foo</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>0child:左值(通常是变量)</li>
<li>1child: 右值(一波操作)</li>
</ul>
<p>追踪数据流变量在这一级上追踪。</p>
<h2 id="ast_array_element">AST_ARRAY_ELEMENT</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2022-03-31-044347.png" alt="截屏2020-07-27 下午9.26.11" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span> =&gt; <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span> =&gt; <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="child-nodes-2">3 child nodes</h1>
<h2 id="ast_method_call">AST_METHOD_CALL</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123118.png" alt="截屏2020-06-20 下午4.52.15" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stu</span>-&gt;<span class="title function_ invoke__">getScore</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: var:stu //比AST_CALL多一个对象名</li>
<li>child1: name: getScore</li>
<li>child2: args:math //arg list</li>
</ul>
<h2 id="ast_static_call">AST_STATIC_CALL</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123122.png" alt="截屏2020-06-20 下午5.00.15" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu::<span class="title function_ invoke__">getScore</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: class:stu （直接指向该类）</li>
<li>child1: name: getScore</li>
<li>child2: args: math</li>
</ul>
<h2 id="ast_conditional">AST_CONDITIONAL</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123125.png" alt="截屏2020-06-20 下午5.05.39" style="zoom:67%;" /></p>
<h1 id="child-nodes-3">4 child nodes</h1>
<h2 id="ast_foreach">AST_FOREACH</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123130.png" alt="截屏2020-06-20 下午3.42.11" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="variable">$k</span>.<span class="variable">$v</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>child0: expr: $arr</li>
<li>child1: keyVar: $k</li>
<li>child2: valueVar: $v</li>
<li>child3: stmts: 代码块list (ZEND_AST_STMT_LIST)</li>
</ul>
<h2 id="zend_ast_for">ZEND_AST_FOR</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-06-29-123134.png" alt="截屏2020-06-20 下午3.50.18" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;=<span class="number">1</span>; <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>child0: init: $i=0</li>
<li>child1: condtion: $i&lt;=1</li>
<li>child2: loop: $i++</li>
<li>child3: 代码块list (ZEND_AST_STMT_LIST)</li>
</ul>
<h1 id="list-nodes">list nodes</h1>
<p>AST_ARG_LIST = 1 //函数参数列表（实参）</p>
<p>AST_ARRAY //数组成员列表</p>
<p><img src="PHP-AST/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%889.26.11-5856522.png" alt="截屏2020-07-27 下午9.26.11" style="zoom:67%;" /></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span> =&gt; <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span> =&gt; <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>AST_EXPR_LIST</p>
<p>AST_STMT_LIST //表达式块</p>
<p>AST_IF //if判断条件列表</p>
<p>AST_SWITCH_LIST</p>
<p>AST_CATCH_LIST</p>
<p>AST_PARAM_LIST //形参</p>
<p>AST_CLOSURE_USES</p>
<p>AST_PROP_DECL</p>
<p>AST_CONST_DECL</p>
<p>AST_CLASS_CONST</p>
<p>AST_NAME_LIST AST_TRAIT_ADAPTATIONS AST_USE AST_TYPE_UNION AST_ATTRIBUTE_LIST</p>
<h2 id="ast_stmt_list">AST_STMT_LIST</h2>
<blockquote>
<p>最常见的块</p>
</blockquote>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-093758.png" alt="截屏2020-07-14 下午5.30.15" style="zoom:67%;" /></p>
<p>儿孙满堂， 一般从这个点跳到块中各个语句中。</p>
<h2 id="ast_if_list">AST_IF_LIST</h2>
<p><img src="https://penlab-1252869057.cos.ap-beijing.myqcloud.com/2020-07-14-093754.png" alt="截屏2020-07-14 下午5.14.28" style="zoom:67%;" /></p>
<hr />
<p>一个分支结构的入口， 因为分支结构是不确定的， 所以是list，从这个点可以纵览分支结构有几个。一般不连控制流边(控制流边一般练到数据操作表达式点上如BINARY_OP，ASSIGN)。</p>
<p>下边的每一个分支入口，都是一个AST_IF（二元）:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AST_IF-&gt; <span class="number">0</span>child(AST_IF_ELEMENT0)</span><br><span class="line">       -&gt; <span class="number">1</span>child(AST_IFELEMENT1)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>child)&#123;</span><br><span class="line">  <span class="number">1</span>child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="number">0</span>child:<span class="literal">null</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">1</span>child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注: AST没有else节点，每个分支块都是一个AST_IF。</p>
<h1 id="declaration-nodes">declaration nodes</h1>
<p>声明式语句</p>
<table>
<thead>
<tr class="header">
<th>/* declaration nodes */</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ZEND_AST_FUNC_DECL</td>
<td></td>
</tr>
<tr class="even">
<td>ZEND_AST_CLOSURE</td>
<td></td>
</tr>
<tr class="odd">
<td>ZEND_AST_METHOD</td>
<td></td>
</tr>
<tr class="even">
<td>ZEND_AST_CLASS</td>
<td></td>
</tr>
<tr class="odd">
<td>ZEND_AST_ARROW_FUNC</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="控制流起始点">控制流起始点：</h2>
<ul>
<li>AST_CLASS</li>
<li>AST_FUNC</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/01/PHP-AST/" data-id="cl1q2wlhh000747w5d6kwetx9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper/" rel="tag">paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pl/" rel="tag">pl</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/pl/" style="font-size: 20px;">pl</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/05/test-math/">test_math</a>
          </li>
        
          <li>
            <a href="/2022/04/06/taint-2/">PHP污点分析</a>
          </li>
        
          <li>
            <a href="/2022/03/31/nlp-1/">NLP入门(一)</a>
          </li>
        
          <li>
            <a href="/2022/02/24/web/">Web应用系中注入类漏洞调研</a>
          </li>
        
          <li>
            <a href="/2022/02/18/data-mining/">data_mining</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 iohex<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  </div>
</body>
</html>